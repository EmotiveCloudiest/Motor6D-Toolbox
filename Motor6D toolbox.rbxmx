<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX01737492D5CE425EBC94BDF51B26F190">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">Motor6D toolbox</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX62B9EE1D403045439450363D4F88F5D9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Motor6d toolbox</string>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{AEE5264F-237B-42B8-8E23-DFFB6A10C47A}</string>
				<ProtectedString name="Source"><![CDATA[--To anyone debugging this, I am sorry.
--This thing is held together by duct tape, hopes and dreams.

--If you feel like yelling at me because of some of the coding choices made in this plugin (and perhaps help me become a better person), 
--feel free to do so over in the DevForum post, or my Discord (@EmotiveCloudiest)

--Plugin Toolbar
local toolbar = plugin:CreateToolbar("Motor6D toolbox")

--Buttons
local OpenEditor = toolbar:CreateButton("Open editor", "Opens the Motor6D toolbox GUI.", "rbxassetid://18907249991")

--Services & Modules
local SelectionService = game:GetService("Selection")
local ChangeHistoryService = game:GetService("ChangeHistoryService")
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local GizmoModule = require(script.GizmoModule)

--Items
local Gizmo = script.Gizmo

--Little blank instance thingies (am i normal for type checking some of these or do i need a sanity check)
local Part0: BasePart = nil
local Part1: BasePart = nil
local ParentInstance: Instance = nil

local WeldPart0: BasePart = nil
local WeldPart1 = {}
local ParentWeldInstance: Instance = nil
local WeldParentInstance: Instance = nil
local WeldSpecificBasePart: BasePart = nil

--Colors!!!! (LISTEN TO THEYAREMANYCOLORS BY FRUMS.)
local RotationGuide = Color3.new(0, 0, 1)
local FrontMark = Color3.new(0, 1, 0)
local UpVector = Color3.new(1,0,0)

--Previous selections
local PreviousSelection = SelectionService:Get()

--Load up the library
local gui = require(script.rblxgui.initialize)(plugin, "rblxgui")

--Time saving functions / general functions

--Make slider (easier)
function MakeSlider(slidertext: string, value: number, min: number, max: number, increment: number)
	local Slider = gui.Labeled.new({
		Text = slidertext,
		Objects = {
			{
				Object = gui.InputField.new({
					Value = value,
					InputSize = 1,
					NoDropdown = true,
					DisableEditing = false
				}),
				Name = "display",
				Size = UDim.new(0,60)
			},{
				Object = gui.Slider.new({
					Min = min,
					Max = max,
					Value = value,
					Increment = increment
				}),
				Name = "slider"
			}
		}
	})

	return Slider
end

--Get slider's value (time saving, also no I have NO IDEA what to put the type check as.)
function GetSliderValue(slider)
	return slider.display.InputFieldFrame.Input.Text
end

--Gizmo Operations
local ActiveGizmos = {} --This thingo just stores active gizmos

local function GetUniqueKey(Obj: Instance) --Gets a motor's uniqueID
	return tostring(Obj:GetDebugId(1))
end

function MakeGizmo(Motor: Motor6D) --This is where all the magic happens (big jank)
	local Parent = Motor.Parent
	local MotorPart0 = Motor.Part0
	
	local UniqueKey = GetUniqueKey(Motor)
	
	if ActiveGizmos[UniqueKey] then
		return
	end
	
	local function DrawGizmo()
		if not Parent then
			RemoveGizmo(Motor)
		else
			local PivotCF = MotorPart0.CFrame * Motor.C0:ToWorldSpace()
			
			GizmoModule.PushProperty("Color3", RotationGuide)
			GizmoModule.Circle:Draw(PivotCF, 4, 20, 360, true)
			GizmoModule.PushProperty("Color3", FrontMark)
			GizmoModule.Arrow:Draw(PivotCF.Position, ((PivotCF.Position) + MotorPart0.CFrame.LookVector*4), 0.25, 1, 9)
			GizmoModule.PushProperty("Color3", UpVector)
			GizmoModule.Arrow:Draw(PivotCF.Position, ((PivotCF.Position) + MotorPart0.CFrame.UpVector*4), 0.25, 1, 9)
			GizmoModule.PushProperty("Color3", RotationGuide)
			local SpinDirPoint = 1
			
			if Motor.DesiredAngle > 0 then
				SpinDirPoint = -1
			elseif Motor.DesiredAngle < 0 then
				SpinDirPoint = 1
			elseif Motor.DesiredAngle == 0 then
				SpinDirPoint = 0
			end
			GizmoModule.Arrow:Draw(PivotCF.Position + MotorPart0.CFrame.UpVector*4, ((PivotCF.Position + MotorPart0.CFrame.UpVector*4) + MotorPart0.CFrame.RightVector*SpinDirPoint), 0.25, 1, 9)
			GizmoModule.Arrow:Draw(PivotCF.Position + MotorPart0.CFrame.UpVector*-4, ((PivotCF.Position + MotorPart0.CFrame.UpVector*-4) + MotorPart0.CFrame.RightVector*-SpinDirPoint), 0.25, 1, 9)
			
			GizmoModule.Ray:Draw(MotorPart0.CFrame.Position,PivotCF.Position)
		end
	end
	
	RunService:BindToRenderStep("MotorGizmo_"..UniqueKey, Enum.RenderPriority.Camera.Value + 1, DrawGizmo)
	
	ActiveGizmos[UniqueKey] = DrawGizmo
end

function RemoveGizmo(Motor: Motor6D) --This is where all the magic is taken away. :(
	local UniqueKey = GetUniqueKey(Motor)
	
	RunService:UnbindFromRenderStep("MotorGizmo_"..UniqueKey)
	
	ActiveGizmos[UniqueKey] = nil
end

--Offset operations
function SetMotorOffset(Motor: Motor6D,PositionOffset: Vector3, OrientationOffset: Vector3) --Ah.
	local Rot = tostring(OrientationOffset)
	local SplitString = string.split(Rot,", ")
	
	local FinalCframe = CFrame.new(PositionOffset) * CFrame.fromEulerAnglesXYZ(math.rad(SplitString[1]),math.rad(SplitString[2]),math.rad(SplitString[3]))
	Motor.C0 = FinalCframe
end

--This one yells at you
function WarnPrompt(warnmessage: string)
	local prompt = gui.TextPrompt.new({
		Title = "Warning!",
		Text = warnmessage,
		Buttons = {"Understood"}
	})
	
	prompt:Clicked(function()
		prompt:Destroy()
	end)
end

--Creates weld
function WeldObjects(WPart0: BasePart, WPart1: BasePart, Name: string?, Parent: Instance?)
	if WPart0 ~= WPart1 then
		local Weld = Instance.new("WeldConstraint")

		Weld.Part0 = WPart0
		Weld.Part1 = WPart1

		if Name then
			Weld.Name = Name
		end

		if Parent then --I have no idea if I actually wanna make a function for this...
			Weld.Parent = Parent
		else
			Weld.Parent = WPart0
		end
	end
end

--IT'S TIME FOR SOME RNG!!!!!!!!!
function GetRandomPart(Model: Instance)
	local GetChildren = Model:GetChildren()
	
	return GetChildren[math.random(1,#GetChildren)]
end

--Volume calculator
function CalcVolume(BasePart: BasePart)
	return (BasePart.Size.X * BasePart.Size.Y * BasePart.Size.Z)
end

--Reset button
function ResetButton(Button,Text,Value)
	Button:SetValue(true)
	Button.Button.TextLabel.Text = Text
	Value = nil
end

--This one is to undo your big oopsies
function setWaypoint()
	ChangeHistoryService:SetWaypoint("Motor6D Toolbox")
end

--Plugin UI / functionality
local widget = gui.PluginWidget.new({
	ID = "Motor6D Toolbox",
	Enabled = false,
	DockState = Enum.InitialDockState.Float
})

--Make that button thing actually do something...
OpenEditor.Click:Connect(function()
	widget.Content.Enabled = not widget.Content.Enabled
end)

--Main page for the Motors section.
local mainpage = gui.Page.new({
	Name = "Motor6D",
	TitlebarMenu = widget.TitlebarMenu,
	Open = true
})

--Here's the main main frame!
local mainframe = gui.ScrollingFrame.new(nil, mainpage.Content)

mainframe:SetMain()

--Basic Motor6D functions.
local BasicInfo = gui.Section.new({
	Text = "Basics",
	Open = true
})

BasicInfo:SetMain()

local BasicInfoMotorsFrame = gui.ListFrame.new({
	Name = "Frame"
})

BasicInfoMotorsFrame:SetMain()

--Selecting what the Part0 is.
local Part0Button = gui.ToggleableButton.new({
	Text = "Part0",
	Value = true,
	ButtonSize = 1
})

Part0Button:Clicked(function()
	local Selection = SelectionService:Get()
	
	if #Selection == 0 then
		Part0Button:SetValue(true)
		Part0Button.Button.TextLabel.Text = "Part0"
		Part0 = nil
	elseif #Selection > 1 then
		if not Part0 then
			Part0Button:SetValue(true)
			Part0Button.Button.TextLabel.Text = "Part0"
		else
			Part0Button:SetValue(false)
		end
		WarnPrompt("You can only select 1 part!")
	elseif #Selection == 1 then
		if Selection[1]:IsA("BasePart") then
			Part0Button:SetValue(false)
			Part0Button.Button.TextLabel.Text = Selection[1].Name
			Part0 = Selection[1]
		else
			if not Part0 then
				Part0Button:SetValue(true)
				Part0Button.Button.TextLabel.Text = "Part0"
			else
				Part0Button:SetValue(false)
			end
			Part0Button:SetValue(false)
			WarnPrompt("You must select a BasePart!")
		end
	end
end)

--Selecting what the Part1 is.
local Part1Button = gui.ToggleableButton.new({
	Text = "Part1",
	Value = true,
	ButtonSize = 1,
})

Part1Button:Clicked(function()
	local Selection = SelectionService:Get()

	if #Selection == 0 then
		Part1Button:SetValue(true)
		Part1Button.Button.TextLabel.Text = "Part1"
		Part1 = nil
	elseif #Selection > 1 then
		if not Part1 then
			Part1Button:SetValue(true)
			Part1Button.Button.TextLabel.Text = "Part1"
		else
			Part1Button:SetValue(false)
		end
		WarnPrompt("You can only select 1 part!")
	elseif #Selection == 1 then
		if Selection[1]:IsA("BasePart") then
			Part1Button:SetValue(false)
			Part1Button.Button.TextLabel.Text = Selection[1].Name
			Part1 = Selection[1]
		else
			if not Part1 then
				Part1Button:SetValue(false)
				Part1Button.Button.TextLabel.Text = "Part1"
			else
				Part1Button:SetValue(false)
			end
			WarnPrompt("You must select a BasePart!")
		end
	end
end)

BasicInfo:SetMain()

gui.Textbox.new({
	Text = "Select a BasePart and click the buttons accordingly.",
	Font = Enum.Font.SourceSans,
	Alignment = Enum.TextXAlignment.Center
})

--Max velocity slider.
local MaxVelocitySlider = MakeSlider("MaxVelocity", 0.1, 0, 1, 0.05)

--BIG JANK INCOMING

MaxVelocitySlider.display:SetDisabled(false)

MaxVelocitySlider.slider:Pressed(function(p)
	MaxVelocitySlider.display:SetDisabled(true)
end)

MaxVelocitySlider.slider:Released(function(p)
	MaxVelocitySlider.display:SetDisabled(false)
end)

MaxVelocitySlider.slider:Changed(function(p)
	MaxVelocitySlider.display:SetValue(math.round(tonumber(p)*1000)/1000) --Me when I am trying to set decimal values but roblox hits me with that 1.0000...01
end)

MaxVelocitySlider.display:Changed(function(p)
	if not MaxVelocitySlider.display.Disabled and p ~= "" or p ~= "." or p ~= "," then --I PROMISE THIS MAKES SENSE.
		if tonumber(p) ~= nil then
			MaxVelocitySlider.slider:SetValue(math.clamp(math.round(tonumber(p)*1000)/1000,0,1))
		end
	end
end)

mainframe:SetMain()

--Advanced info section (the cool kids section)
local AdvancedInfo = gui.Section.new({
	Text = "Advanced",
	Open = false
})

AdvancedInfo:SetMain()

--Name the motor after it's Part0 (the better option)
local UsePart0Name = gui.Labeled.new({
	Text = "Name the motor after it's Part0",
	LabelSize = 0.5,
	Object = gui.Checkbox.new({
		Value = false
	})
})

--Parent the motor under a different instance (just so you can finally learn HOW TO ORGANIZE YOUR MOTORS.)
local UseParent = gui.Labeled.new({
	Text = "Parent to selected",
	LabelSize = 0.5,
	Object = gui.ToggleableButton.new({
		Text = "Instance",
		Value = true,
		ButtonSize = 1
	})
})

UseParent.Object:Clicked(function()
	local Selection = SelectionService:Get()

	if #Selection == 0 then
		UseParent.Object:SetValue(true)
		UseParent.Object.Button.TextLabel.Text = "Instance"
		ParentInstance = nil
	elseif #Selection > 1 then
		if not ParentInstance then
			UseParent.Object:SetValue(true)
			UseParent.Object.Button.TextLabel.Text = "Instance"
		else
			UseParent.Object:SetValue(false)
		end
		WarnPrompt("You can only select 1 instance!")
	elseif #Selection == 1 then
		UseParent.Object:SetValue(false)
		UseParent.Object.Button.TextLabel.Text = Selection[1].Name
		ParentInstance = Selection[1]
	end
end)

--Sentence the motor to eternal spin
local InfiniteSpinInfo = gui.Section.new({
	Text = "Infinite spin",
	Open = false
})

InfiniteSpinInfo:SetMain()

--Decide it's fate
local InfiniteSpin = gui.Labeled.new({
	Text = "Make motor spin infinitely",
	LabelSize = 0.5,
	Object = gui.Checkbox.new({
		Value = false
	})
})

--Decide which direction it's fate is destined to
local SpinDirection = gui.Labeled.new({
	Text = "Spin direction",
	LabelSize = 0.5,
	Object = gui.InputField.new({
		CurrentItem = "Positive",
		Items = {
			{
				Name = "Positive",
				Value = "Positive"
			},
			{
				Name = "Negative",
				Value = "Negative"
			},
		},
		DisableEditing = true
	})
})

AdvancedInfo:SetMain()

--Woooah! Gizmos!!!
local GizmoSettings = gui.Section.new({
	Text = "Gizmos",
	Open = false
})

GizmoSettings:SetMain()

--Make gizmos visible or invisible
local GizmosVisibility = gui.Labeled.new({
	Text = "Show gizmos",
	LabelSize = 0.5,
	Object = gui.Checkbox.new({
		Value = true
	})
})

GizmosVisibility.Object:Clicked(function()
	GizmoModule.SetEnabled(GizmosVisibility.Object.Value)
end)

--Ooo! Colors!
local GizmoColors = gui.Section.new({
	Text = "Colors",
	Open = false
})

GizmoColors:SetMain()

local GizmoRotationColor = gui.Labeled.new({
	Text = "Rotation guide",
	LabelSize = 0.5,
	Object = gui.ColorInput.new({
		Value = RotationGuide
	})
})

GizmoRotationColor.Object:Changed(function()
	RotationGuide = GizmoRotationColor.Object.Value
end)

local GizmoFrontColor = gui.Labeled.new({
	Text = "Look vector",
	LabelSize = 0.5,
	Object = gui.ColorInput.new({
		Value = FrontMark
	})
})

GizmoFrontColor.Object:Changed(function()
	FrontMark = GizmoFrontColor.Object.Value
end)

local GizmoUpColor = gui.Labeled.new({
	Text = "Up vector",
	LabelSize = 0.5,
	Object = gui.ColorInput.new({
		Value = UpVector
	})
})

GizmoUpColor.Object:Changed(function()
	UpVector = GizmoUpColor.Object.Value
end)

AdvancedInfo:SetMain()

--Here we go. May God have mercy on mine and your wretched soul :prayge:
local C0Offsets = gui.Section.new({
	Text = "C0 offsets",
	Open = false
})

C0Offsets:SetMain()

--The positions
local C0Position = gui.Section.new({
	Text = "Position",
	Open = true
})

C0Position:SetMain()

local XPosSlider = MakeSlider("X", 0, -2, 2, 0.005)

XPosSlider.display:SetDisabled(false)

XPosSlider.slider:Pressed(function(p)
	XPosSlider.display:SetDisabled(true)
end)

XPosSlider.slider:Released(function(p)
	XPosSlider.display:SetDisabled(false)
end)

XPosSlider.slider:Changed(function(p)
	XPosSlider.display:SetValue(math.round(tonumber(p)*1000)/1000)
end)

XPosSlider.display:Changed(function(p)
	if not XPosSlider.display.Disabled and p ~= "" or p ~= "." or p ~= "," then
		if tonumber(p) ~= nil then
			XPosSlider.slider:SetValue(math.clamp(math.round(tonumber(p)*1000)/1000,-2,2))
		end
	end
end)

local YPosSlider = MakeSlider("Y", 0, -2, 2, 0.005)

YPosSlider.display:SetDisabled(false)

YPosSlider.slider:Pressed(function(p)
	YPosSlider.display:SetDisabled(true)
end)

YPosSlider.slider:Released(function(p)
	YPosSlider.display:SetDisabled(false)
end)

YPosSlider.slider:Changed(function(p)
	YPosSlider.display:SetValue(math.round(tonumber(p)*1000)/1000)
end)

YPosSlider.display:Changed(function(p)
	if not YPosSlider.display.Disabled and p ~= "" or p ~= "." or p ~= "," then
		if tonumber(p) ~= nil then
			YPosSlider.slider:SetValue(math.clamp(math.round(tonumber(p)*1000)/1000,-2,2))
		end
	end
end)

local ZPosSlider = MakeSlider("Z", 0, -2, 2, 0.005)

ZPosSlider.display:SetDisabled(false)

ZPosSlider.slider:Pressed(function(p)
	ZPosSlider.display:SetDisabled(true)
end)

ZPosSlider.slider:Released(function(p)
	ZPosSlider.display:SetDisabled(false)
end)

ZPosSlider.slider:Changed(function(p)
	ZPosSlider.display:SetValue(math.round(tonumber(p)*1000)/1000)
end)

ZPosSlider.display:Changed(function(p)
	if not ZPosSlider.display.Disabled and p ~= "" or p ~= "." or p ~= "," then
		if tonumber(p) ~= nil then
			ZPosSlider.slider:SetValue(math.clamp(math.round(tonumber(p)*1000)/1000,-2,2))
		end
	end
end)

C0Offsets:SetMain()

--The rotations
local C0Orientation = gui.Section.new({
	Text = "Orientation",
	Open = true
})

C0Orientation:SetMain()

local XRotSlider = MakeSlider("X", 0, -360, 360, 1)

XRotSlider.display:SetDisabled(false)

XRotSlider.slider:Pressed(function(p)
	XRotSlider.display:SetDisabled(true)
end)

XRotSlider.slider:Released(function(p)
	XRotSlider.display:SetDisabled(false)
end)

XRotSlider.slider:Changed(function(p)
	XRotSlider.display:SetValue(math.round(tonumber(p)*1000)/1000)
end)

XRotSlider.display:Changed(function(p)
	if not XRotSlider.display.Disabled and p ~= "" or p ~= "." or p ~= "," then
		if tonumber(p) ~= nil then
			XRotSlider.slider:SetValue(math.clamp(math.round(tonumber(p)*1000)/1000,-360,360))
		end
	end
end)

local YRotSlider = MakeSlider("Y", 0, -360, 360, 1)

YRotSlider.display:SetDisabled(false)

YRotSlider.slider:Pressed(function(p)
	YRotSlider.display:SetDisabled(true)
end)

YRotSlider.slider:Released(function(p)
	YRotSlider.display:SetDisabled(false)
end)

YRotSlider.slider:Changed(function(p)
	YRotSlider.display:SetValue(math.round(tonumber(p)*1000)/1000)
end)

YRotSlider.display:Changed(function(p)
	if not YRotSlider.display.Disabled and p ~= "" or p ~= "." or p ~= "," then
		if tonumber(p) ~= nil then
			YRotSlider.slider:SetValue(math.clamp(math.round(tonumber(p)*1000)/1000,-360,360))
		end
	end
end)

local ZRotSlider = MakeSlider("Z", 0, -360, 360, 1)

ZRotSlider.display:SetDisabled(false)

ZRotSlider.slider:Pressed(function(p)
	ZRotSlider.display:SetDisabled(true)
end)

ZRotSlider.slider:Released(function(p)
	ZRotSlider.display:SetDisabled(false)
end)

ZRotSlider.slider:Changed(function(p)
	ZRotSlider.display:SetValue(math.round(tonumber(p)*1000)/1000)
end)

ZRotSlider.display:Changed(function(p)
	if not ZRotSlider.display.Disabled and p ~= "" or p ~= "." or p ~= "," then
		if tonumber(p) ~= nil then
			ZRotSlider.slider:SetValue(math.clamp(math.round(tonumber(p)*1000)/1000,-360,360))
		end
	end
end)

C0Offsets:SetMain()

--Apply those offsets (because I don't feel like having to individually check each slider's change etc.)
local ApplyOffset = gui.Button.new({
	Text = "ApplyOffset",
	ButtonSize = 1
})

ApplyOffset:Clicked(function()
	setWaypoint()
	
	local Selected = SelectionService:Get()
	
	if #Selected ~= 0 then
		for _, Motor in ipairs(Selected) do
			if Motor:IsA("Motor6D") then
				local Position = Vector3.new(GetSliderValue(XPosSlider),GetSliderValue(YPosSlider),GetSliderValue(ZPosSlider))
				local Rotation = Vector3.new(GetSliderValue(XRotSlider),GetSliderValue(YRotSlider),GetSliderValue(ZRotSlider))
				
				SetMotorOffset(Motor,Position,Rotation)
			end
		end
	end
	
	setWaypoint()
end)

mainframe:SetMain()

--Actually create the motors!
local CreateMotorButton = gui.Button.new({
	Text = "Create motor",
	ButtonSize = 1
})

CreateMotorButton:Clicked(function()
	setWaypoint()
	
	if Part0 and Part1 then
		local Motor = Instance.new("Motor6D")
		Motor.Name = "Motor"
		Motor.Part0 = Part0
		Motor.Part1 = Part1
		
		--Check name
		if UsePart0Name.Object.Value == true then
			Motor.Name = Part0.Name
		end
		
		--Infinite spin
		if InfiniteSpin.Object.Value == true then
			if SpinDirection.Object.Value == "Positive" then
				Motor.DesiredAngle = math.huge
			else
				Motor.DesiredAngle = -math.huge
			end
		end
		
		Motor.MaxVelocity = GetSliderValue(MaxVelocitySlider)

		--Calculate C1
		Motor.C1 = Part1.CFrame:inverse() * Part0.CFrame

		--Parent motor
		if ParentInstance then
			Motor.Parent = ParentInstance
		else
			Motor.Parent = Part0
		end
		
		--SetC0
		local Position = Vector3.new(GetSliderValue(XPosSlider),GetSliderValue(YPosSlider),GetSliderValue(ZPosSlider))
		local Rotation = Vector3.new(GetSliderValue(XRotSlider),GetSliderValue(YRotSlider),GetSliderValue(ZRotSlider))

		SetMotorOffset(Motor,Position,Rotation)
		
		SelectionService:Set({Motor})
		
		ResetButton(Part0Button,"Part0",Part0)
		ResetButton(Part1Button,"Part1",Part1)
	else
		WarnPrompt("You must select a Part0 and Part1!")
	end
	
	setWaypoint()
end)

--Detecting selections (this thing was a pain, ROBLOX PLEASE JUST ADD CHECKING FOR DESELECTING :despair:)
SelectionService.SelectionChanged:Connect(function()
	local Selected = SelectionService:Get()
	
	--Very, VERY HACKY solution (which I totally didn't use ChatGPT's help for)
	for UniqueKey, _ in pairs(ActiveGizmos) do
		motorStillSelected = false --STOP YELLING AT ME ME IT'S NOT AN ERROR IT FUNCTIONS :RAGE:
		for _, Motor in ipairs(Selected) do
			if GetUniqueKey(Motor) == UniqueKey then
				motorStillSelected = true
				break
			end
		end
	end
	
	--Check select
	for _, Motor in ipairs(Selected) do
		if Motor:IsA("Motor6D") and not table.find(PreviousSelection,Motor) and not ActiveGizmos[GetUniqueKey(Motor)] then
			MakeGizmo(Motor)
		end
	end
	
	--Check deselect
	for _, Motor in ipairs(PreviousSelection) do
		if not motorStillSelected then
			RemoveGizmo(Motor)
		end
	end
	
	PreviousSelection = Selected
end)

--And now for welding all that

--Main page for the Welds section.
local mainpage = gui.Page.new({
	Name = "Welding",
	TitlebarMenu = widget.TitlebarMenu,
	Open = false
})

--Here's the main main frame!
local weldsMainframe = gui.ScrollingFrame.new(nil, mainpage.Content)

weldsMainframe:SetMain()

--Basic Welding functions.
local WeldBasicInfo = gui.Section.new({
	Text = "Basics",
	Open = true
})

WeldBasicInfo:SetMain()

local BasicInfoWeldsFrame = gui.ListFrame.new({
	Name = "Frame"
})

BasicInfoWeldsFrame:SetMain()

--Weld part0 button
local Weld0Button = gui.ToggleableButton.new({
	Text = "Part0",
	Value = true,
	ButtonSize = 1
})

--Weld part1(s) button
local Weld1Button = gui.ToggleableButton.new({
	Text = "Part1(s)",
	Value = true,
	ButtonSize = 1,
})

--Selecting what the Part0 is.
Weld0Button:Clicked(function()
	local Selection = SelectionService:Get()

	if #Selection == 0 then
		Weld0Button:SetValue(true)
		Weld0Button.Button.TextLabel.Text = "Part0"
		WeldPart0 = nil
	elseif #Selection > 1 then
		if not WeldPart0 then
			Weld0Button:SetValue(true)
			Weld0Button.Button.TextLabel.Text = "Part0"
		else
			Weld0Button:SetValue(false)
		end
		WarnPrompt("You can only select 1 part!")
	elseif #Selection == 1 then
		if Selection[1]:IsA("BasePart") then
			Weld0Button:SetValue(false)
			Weld0Button.Button.TextLabel.Text = Selection[1].Name
			WeldPart0 = Selection[1]
		else
			if not WeldPart0 then
				Weld0Button:SetValue(true)
				Weld0Button.Button.TextLabel.Text = "Part0"
			else
				Weld0Button:SetValue(false)
			end
			WarnPrompt("You must select a BasePart!")
		end
	end
end)

--Selecting what the Part1 is.
Weld1Button:Clicked(function()
	local Selection = SelectionService:Get()

	if #Selection == 0 then
		Weld1Button:SetValue(true)
		Weld1Button.Button.TextLabel.Text = "Part1(s)"
		WeldPart1 = Selection
	else
		WeldPart1 = Selection

		if #Selection == 1 then
			Weld1Button:SetValue(false)
			Weld1Button.Button.TextLabel.Text = WeldPart1[1].Name
		elseif #Selection > 1 then
			Weld1Button:SetValue(false)
			Weld1Button.Button.TextLabel.Text = WeldPart1[1].Name..", "..WeldPart1[2].Name..if #Selection > 2 then "..." else ""
		end
	end
end)

WeldBasicInfo:SetMain()

gui.Textbox.new({
	Text = "Select a BasePart(s) and click the buttons accordingly.",
	Font = Enum.Font.SourceSans,
	Alignment = Enum.TextXAlignment.Center
})

weldsMainframe:SetMain()

--Advanced Welding functions.
local WeldAdvancedInfo = gui.Section.new({
	Text = "Advanced",
	Open = false
})

WeldAdvancedInfo:SetMain()

--Name the motor after it's Part0 (the better option)
local WeldPart0Name = gui.Labeled.new({
	Text = "Name the weld(s) after Part0",
	LabelSize = 0.5,
	Object = gui.Checkbox.new({
		Value = false
	})
})

--Smart weld (because like, you just click, like, get it, right?)
local SmartWeld = gui.Section.new({
	Text = "Smart weld (EXPERIMENTAL)",
	Open = false
})

SmartWeld:SetMain()

gui.Textbox.new({
	Text = "Select Models (or Folders) and the welding option.",
	Font = Enum.Font.SourceSans,
	Alignment = Enum.TextXAlignment.Center,
	TextSize = 13
})

--Decide which option smart weld will take
local SmartWeldOption = gui.Labeled.new({
	Text = "Smart Weld method",
	LabelSize = 0.5,
	Object = gui.InputField.new({
		CurrentItem = "Weld to random",
		Items = {
			{
				Name = "Weld to random",
				Value = "Weld to random"
			},
			{
				Name = "Weld to largest",
				Value = "Weld to largest"
			},
			{
				Name = "Weld to instance",
				Value = "Weld to instance"
			},
			{
				Name = "Weld to named",
				Value = "Weld to named"
			}
		},
		DisableEditing = true
	})
})

--Welds all parts to a selected BasePart
local WeldToBasePart = gui.Labeled.new({
	Text = "Weld to set BasePart",
	LabelSize = 0.5,
	Object = gui.ToggleableButton.new({
		Text = "Instance",
		Value = true,
		ButtonSize = 1
	})
})

WeldToBasePart.Object:Clicked(function()
	local Selection = SelectionService:Get()

	if #Selection == 0 then
		WeldToBasePart.Object:SetValue(true)
		WeldToBasePart.Object.Button.TextLabel.Text = "Instance"
		WeldSpecificBasePart = nil
	elseif #Selection > 1 then
		if not ParentInstance then
			WeldToBasePart.Object:SetValue(true)
			WeldToBasePart.Object.Button.TextLabel.Text = "Instance"
		else
			WeldToBasePart.Object:SetValue(false)
		end
		WarnPrompt("You can only select 1 instance!")
	elseif #Selection == 1 then
		if Selection[1]:IsA("BasePart") then
			WeldToBasePart.Object:SetValue(false)
			WeldToBasePart.Object.Button.TextLabel.Text = Selection[1].Name
			WeldSpecificBasePart = Selection[1]
		else
			WarnPrompt("You must select a BasePart!")
		end
	end
end)

--Welds all the parts to a part under a specific name
local WeldToNamed = gui.Labeled.new({
	Text = "Weld to named BasePart",
	LabelSize = 0.5,
	Object = gui.InputField.new({
		Value = "",
		InputSize = 1,
		NoDropdown = true,
		DisableEditing = false
	})
})

--Actually create the smart welds!
local CreateSmartWeldsButton = gui.Button.new({
	Text = "Create Smart Weld(s)",
	ButtonSize = 1
})

CreateSmartWeldsButton:Clicked(function()
	setWaypoint()
	
	local Selection = SelectionService:Get()
	
	if #Selection > 0 then
		if SmartWeldOption.Object.Value == "Weld to random" then
			for _, WeldThing in ipairs(Selection) do
				if WeldThing:IsA("Model") or WeldThing:IsA("Folder") then
					local RandomPart = GetRandomPart(WeldThing)

					for _, WeldPart in WeldThing:GetChildren() do
						if WeldPart:IsA("BasePart") then
							WeldObjects(RandomPart,WeldPart,if WeldPart0Name.Object.Value == true then RandomPart.Name.." to "..WeldPart.Name else nil)
						end
					end
				end
			end
		elseif SmartWeldOption.Object.Value == "Weld to largest" then
			for _, WeldThing in ipairs(Selection) do
				if WeldThing:IsA("Model") or WeldThing:IsA("Folder") then
					local LargestPart = GetRandomPart(WeldThing)
					
					--Get largest part
					for _, WeldPart in WeldThing:GetChildren() do
						if WeldPart:IsA("BasePart") then
							local PartVolume = CalcVolume(WeldPart)

							if PartVolume > CalcVolume(LargestPart) then
								LargestPart = WeldPart
							end
						end
					end

					--Weld it once it's over (is there a better way to do this? Maybe. Will I do it? Not sure. -2:30AM Emotive)
					for _, WeldAgain in WeldThing:GetChildren() do
						if WeldAgain:IsA("BasePart") then
							WeldObjects(LargestPart, WeldAgain, if WeldPart0Name.Object.Value == true then LargestPart.Name.." to "..WeldAgain.Name else nil)
						end
					end
				end
			end
		elseif SmartWeldOption.Object.Value == "Weld to instance" then
			if WeldSpecificBasePart then
				for _, WeldThing in ipairs(Selection) do
					if WeldThing:IsA("Model") or WeldThing:IsA("Folder") then
						for _, WeldPart in WeldThing:GetChildren() do
							if WeldPart:IsA("BasePart") then
								WeldObjects(WeldSpecificBasePart,WeldPart,if WeldPart0Name.Object.Value == true then WeldSpecificBasePart.Name.." to "..WeldPart.Name else nil)
							end
						end
					end
				end

				ResetButton(WeldToBasePart.Object,"Instance",WeldSpecificBasePart)
			else
				WarnPrompt("You must select a BasePart to weld to!")
			end
		elseif SmartWeldOption.Object.Value == "Weld to named" then
			for _, WeldThing in ipairs(Selection) do
				if WeldThing:IsA("Model") or WeldThing:IsA("Folder") or WeldThing:IsA("BasePart") then
					local NamedPart = nil

					--Look for the part
					for _, WeldPart in WeldThing:GetChildren() do
						if WeldPart:IsA("BasePart") and WeldPart.Name == WeldToNamed.Object.InputFieldFrame.Input.Text then
							NamedPart = WeldPart
						end
					end

					--Weld it
					if NamedPart then
						for _, WeldAgain in WeldThing:GetChildren() do
							if WeldAgain:IsA("BasePart") then
								WeldObjects(NamedPart, WeldAgain, if WeldPart0Name.Object.Value == true then NamedPart.Name.." to "..WeldAgain.Name else nil)
							end
						end
					else
						--Why not use a prompt? Well... They stack. Wouldn't wanna spam click all of those off if you did an oopsie, would ya?
						warn("Couldn't find a BasePart named "..WeldToNamed.Object.InputFieldFrame.Input.Text.." inside of "..WeldThing.Name)
					end
				end
			end
		end
	end
	
	setWaypoint()
end)

weldsMainframe:SetMain()

--Actually create the welds!
local CreateWeldsButton = gui.Button.new({
	Text = "Create weld(s)",
	ButtonSize = 1
})

CreateWeldsButton:Clicked(function()
	setWaypoint()

	if WeldPart0 and #WeldPart1 ~= 0 then
		for _, WeldingPart1: BasePart in ipairs(WeldPart1) do
			if WeldingPart1:IsA("BasePart") then
				WeldObjects(WeldPart0,WeldingPart1,if WeldPart0Name.Object.Value == true then WeldPart0.Name.." to "..WeldingPart1.Name else nil)
			else
				--Same thing applies here.
				warn("Couldn't weld "..WeldingPart1.Name.." because it is not a BasePart!")
			end
		end
		
		ResetButton(Weld0Button,"Part0",WeldPart0)
		ResetButton(Weld1Button,"Part1(s)",WeldPart1)
	else
		WarnPrompt("You must select a Part0 and Part1!")
	end

	setWaypoint()
end)]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="LineHandleAdornment" referent="RBXFEAADC77A96744C1B906039D5C444ADC">
				<Properties>
					<token name="AdornCullingMode">0</token>
					<Ref name="Adornee">null</Ref>
					<bool name="AlwaysOnTop">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<CoordinateFrame name="CFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<Color3 name="Color3">
						<R>0</R>
						<G>0</G>
						<B>1</B>
					</Color3>
					<bool name="DefinesCapabilities">false</bool>
					<float name="Length">5</float>
					<string name="Name">Gizmo</string>
					<Vector3 name="SizeRelativeOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="Thickness">6</float>
					<float name="Transparency">0.5</float>
					<bool name="Visible">true</bool>
					<int name="ZIndex">-1</int>
				</Properties>
				<Item class="ConeHandleAdornment" referent="RBX7E56C6FBDC2F44C0A7D646E7A7827F3E">
					<Properties>
						<token name="AdornCullingMode">0</token>
						<Ref name="Adornee">null</Ref>
						<bool name="AlwaysOnTop">true</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<Color3 name="Color3">
							<R>0</R>
							<G>0</G>
							<B>1</B>
						</Color3>
						<bool name="DefinesCapabilities">false</bool>
						<float name="Height">0.5</float>
						<string name="Name">ConeHandleAdornment</string>
						<float name="Radius">0.125</float>
						<Vector3 name="SizeRelativeOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>-10</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="Transparency">0.5</float>
						<bool name="Visible">true</bool>
						<int name="ZIndex">-1</int>
					</Properties>
					<Item class="CylinderHandleAdornment" referent="RBXB1D804370C8740018496C1EB68B47A61">
						<Properties>
							<token name="AdornCullingMode">0</token>
							<Ref name="Adornee">null</Ref>
							<bool name="AlwaysOnTop">true</bool>
							<float name="Angle">270</float>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<CoordinateFrame name="CFrame">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<Color3 name="Color3">
								<R>0</R>
								<G>1</G>
								<B>0</B>
							</Color3>
							<bool name="DefinesCapabilities">false</bool>
							<float name="Height">0.100000001</float>
							<float name="InnerRadius">2.9000001</float>
							<string name="Name">CylinderHandleAdornment</string>
							<float name="Radius">3</float>
							<Vector3 name="SizeRelativeOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="Transparency">0.5</float>
							<bool name="Visible">true</bool>
							<int name="ZIndex">-1</int>
						</Properties>
						<Item class="ConeHandleAdornment" referent="RBX1C1BE801E8784BD1BB57C92F9763B4E9">
							<Properties>
								<token name="AdornCullingMode">0</token>
								<Ref name="Adornee">null</Ref>
								<bool name="AlwaysOnTop">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<CoordinateFrame name="CFrame">
									<X>0</X>
									<Y>-2.95000005</Y>
									<Z>0</Z>
									<R00>-4.37113883e-08</R00>
									<R01>0</R01>
									<R02>-1</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>1</R20>
									<R21>0</R21>
									<R22>-4.37113883e-08</R22>
								</CoordinateFrame>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<Color3 name="Color3">
									<R>0</R>
									<G>1</G>
									<B>0</B>
								</Color3>
								<bool name="DefinesCapabilities">false</bool>
								<float name="Height">1</float>
								<string name="Name">ArrowOffset</string>
								<float name="Radius">0.25</float>
								<Vector3 name="SizeRelativeOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="Transparency">0.5</float>
								<bool name="Visible">true</bool>
								<int name="ZIndex">-1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX4407A530F21B45908AAB3C17CE573868">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">rblxgui</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX7F8E3FDC66984D8C8E1F486EC4C652BB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">initialize</string>
						<string name="ScriptGuid">{b5c22bec-1c85-773f-817f-2c3e4007e2c8}</string>
						<ProtectedString name="Source"><![CDATA[local GV = require(script.Parent.lib.PluginGlobalVariables)
local function requireall(p,id)
    GV.PluginObject = p
    local library = {}
    if id then require(script.Parent.lib.PluginGlobalVariables).PluginID = id end
    for _, i in pairs(script.Parent.lib:GetDescendants()) do
        if i:IsA("ModuleScript") then
            library[i.Name] = require(i)
        end
    end
    return library
end
return requireall]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX7D0BBCCF9BC74CD8B8A71EFA0B1E3D49">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">lib</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX7967163B59354C939F95DEF4D5D5D268">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Frames</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX0F4C852F365640E79A80A10DF8119B5E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">BackgroundFrame</string>
								<string name="ScriptGuid">{d679ac0e-3366-612d-706e-b8768fcd5f3a}</string>
								<ProtectedString name="Source"><![CDATA[local BackgroundFrame = {}
BackgroundFrame.__index = BackgroundFrame

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local GUIFrame = require(GV.FramesDir.GUIFrame)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
setmetatable(BackgroundFrame,GUIFrame)


function BackgroundFrame.new(Arguments, Parent)
    local self = GUIFrame.new(Arguments, Parent)
    setmetatable(self,BackgroundFrame)
    -- generate background frame
    self.Content = Instance.new("Frame", self.Parent)
    ThemeManager.ColorSync(self.Content, "BackgroundColor3", Enum.StudioStyleGuideColor.MainBackground)
    self.Content.Size = UDim2.new(1,0,1,0)
    self.Content.Name = "Background"
    self.Content.ZIndex = 0
    return self
end

return BackgroundFrame]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5748799FD2F947BF92D0645D9B423519">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">GUIFrame</string>
								<string name="ScriptGuid">{63026fb4-4a41-4d04-1474-f31e30d1e5ce}</string>
								<ProtectedString name="Source"><![CDATA[local GUIFrame = {}
GUIFrame.__index = GUIFrame
local GV = require(script.Parent.Parent.PluginGlobalVariables)
local GUIElement = require(GV.LibraryDir.GUIElement)
setmetatable(GUIFrame,GUIElement)

GV.MainGUI = nil

function GUIFrame.new(Arguments, Parent)
    local self = GUIElement.new(Arguments, Parent or GV.MainGUI)
    setmetatable(self,GUIFrame)
    self.Content = nil
    return self
end

function GUIFrame:SetMain()
    GV.MainGUI = self.Content
end

return GUIFrame]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX10F952EEF8554564A5F44AAFDC7623C5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ListFrame</string>
								<string name="ScriptGuid">{7b76fc45-7731-f587-3812-bcda04a52cfc}</string>
								<ProtectedString name="Source"><![CDATA[local ListFrame = {}
ListFrame.__index = ListFrame
local GV = require(script.Parent.Parent.PluginGlobalVariables)
local GUIFrame = require(GV.FramesDir.GUIFrame)
setmetatable(ListFrame,GUIFrame)
local Count = 0


-- Name, Height
function ListFrame.new(Arguments, Parent)
    local self = GUIFrame.new(Arguments, Parent)
    setmetatable(self,ListFrame)
    Count = Count + 1;
    self.Arguments.Height = self.Arguments.Height or 28
    self.Content = Instance.new("Frame", self.Parent)
    self.Content.BackgroundTransparency = 1
    self.Content.Size = UDim2.new(1,0,0,self.Arguments.Height)
    self.Content.Name = Count
    if self.Arguments.Name then self.Content.Name = self.Content.Name .. ": " .. self.Arguments.Name end
    -- layout (used for stacking multiple elements in one row)
    self.Layout = Instance.new("UIGridLayout", self.Content)
    self.Layout.SortOrder = Enum.SortOrder.LayoutOrder
    self.Layout.FillDirection = Enum.FillDirection.Vertical
    self.Layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    self.Layout.Changed:Connect(function(p)
        if p == "AbsoluteCellCount" and self.Layout.AbsoluteCellCount.X > 0 then
            self.Layout.CellSize = UDim2.new(1/self.Layout.AbsoluteCellCount.X,0,1,0)
        end
    end)
    -- self.Padding for elements in frame
    self.Padding = Instance.new("UIPadding", self.Content)
    self.Padding.PaddingBottom, self.Padding.PaddingLeft, self.Padding.PaddingRight, self.Padding.PaddingTop = UDim.new(0,2), UDim.new(0,2), UDim.new(0,2), UDim.new(0,2)
    return self
end

return ListFrame]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX96A1037AFDB74D7AADF9636FF7099F56">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Page</string>
								<string name="ScriptGuid">{54f70b2c-c042-8c2a-c434-ee876f3ea56e}</string>
								<ProtectedString name="Source"><![CDATA[local Page = {}
Page.__index = Page

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local InputManager = require(GV.ManagersDir.InputManager)
local GUIFrame = require(GV.FramesDir.GUIFrame)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
setmetatable(Page,GUIFrame)
local PageNum = 0
GV.PluginPages = {}

function Page:SetState(State)
    self.Open = State
    self.Content.Visible = State
    local Transparency = 1
    local OppositeTransparency = 0
    if State then Transparency, OppositeTransparency = 0, 1 end
    self.TabFrame.BackgroundTransparency, self.TopBorder.BackgroundTransparency, self.LeftBorder.BackgroundTransparency, self.RightBorder.BackgroundTransparency = Transparency, Transparency, Transparency, Transparency
    self.Tab.BackgroundTransparency = OppositeTransparency
    self.TabFrame.ZIndex, self.Tab.ZIndex, self.TopBorder.ZIndex, self.LeftBorder.ZIndex, self.RightBorder.ZIndex = OppositeTransparency + 2, OppositeTransparency + 2, OppositeTransparency + 2, OppositeTransparency + 2, OppositeTransparency + 2
    if State then
        ThemeManager.ColorSync(self.Tab, "TextColor3", Enum.StudioStyleGuideColor.MainText)
    else
        ThemeManager.ColorSync(self.Tab, "TextColor3", Enum.StudioStyleGuideColor.TitlebarText,nil,nil,nil,true)
    end
end

-- Name, TitlebarMenu, Open, TabSize, ID
function Page.new(Arguments, Parent)
    local self = GUIFrame.new(Arguments, Parent)
    self.TitlebarMenu = self.Arguments.TitlebarMenu or self.Parent.TitlebarMenu
    setmetatable(self,Page)
    PageNum += 1
    self.ID = self.Arguments.ID or self.Arguments.Name
    self.TabFrame = Instance.new("Frame", self.TitlebarMenu.TabContainer)
    self.TabFrame.Name = PageNum
    self.TabFrame.BorderSizePixel = 0
    ThemeManager.ColorSync(self.TabFrame, "BackgroundColor3", Enum.StudioStyleGuideColor.MainBackground)
    self.Tab = Instance.new("TextButton", self.TabFrame)
    self.Tab.Size = UDim2.new(1, 0, 0, 24)
    ThemeManager.ColorSync(self.Tab, "BackgroundColor3", Enum.StudioStyleGuideColor.Titlebar,nil,nil,nil,true)
    self.Tab.BorderSizePixel = 0
    self.Tab.Font = Enum.Font.SourceSans
    self.Tab.Text = self.Arguments.Name
    self.Tab.TextSize = 14
    self.Tab.Name = "Tab"
    self.InsideWidget = true
    if not self.Arguments.TabSize then
        local function sync()
            self.TabFrame.Size = UDim2.new(0,self.Tab.TextBounds.X+1.5*self.Tab.TextSize, 0, 24)
        end
        self.Tab.Changed:Connect(function(p)
            if p == "TextBounds" then sync() end
        end)
        sync()
    else
        self.TabFrame.Size = UDim2.new(0,self.Arguments.TabSize,0,30)
    end
    self.Tab.MouseButton1Down:Connect(function(x)
        if self.TabDragging then return end
        GV.SelectedPage = self
        self.TitlebarMenu:SetActive(self.ID)
        self.TabDragging = true
        self.InitialX = self.TabFrame.Position.X.Offset - x - self.TitlebarMenu.ScrollingMenu.CanvasPosition.X
    end)
    InputManager.AddInputEvent("InputEnded", function(p)
        if not self.TabDragging or p.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
        GV.SelectedPage = nil
        self.TabDragging = false
        self.TitlebarMenu:FixPageLayout()
    end)
    InputManager.AddInputEvent("MouseEnter", function()
        if not self.TabDragging and self.InsideWidget then return end
        self.TitlebarMenu:AddPage(self)
        self.InsideWidget = true
        GV.SelectedPage = nil
        self.TabDragging = false
        self.TitlebarMenu:FixPageLayout()
    end)
    local PreviousMouseX = 0
    InputManager.AddInputEvent("MouseMoved", function(x)
        PreviousMouseX = x
        if not self.TabDragging then return end
        self.TabFrame.Position = UDim2.new(0,x + self.InitialX + self.TitlebarMenu.ScrollingMenu.CanvasPosition.X,0,0)
        if self.InsideWidget then self.TitlebarMenu:BeingDragged(self.ID) end
    end)
    self.TitlebarMenu.ScrollingMenu.Changed:Connect(function(p)
        if not p == "CanvasPosition" or not self.TabDragging then return end
        self.TabFrame.Position = UDim2.new(0,PreviousMouseX + self.InitialX + self.TitlebarMenu.ScrollingMenu.CanvasPosition.X,0,0)
        if self.InsideWidget then self.TitlebarMenu:BeingDragged(self.ID) end
    end)
    InputManager.AddInputEvent("MouseLeave", function()
        if not self.TabDragging then return end
        self.TabDragging = false
        self.InsideWidget = false
        GV.PluginObject:StartDrag({})
        self.TitlebarMenu:RemovePage(self)
    end)
    ThemeManager.ColorSync(self.Tab, "TextColor3", Enum.StudioStyleGuideColor.TitlebarText,nil,nil,nil,true)
    self.TopBorder = Instance.new("Frame", self.TabFrame)
    self.TopBorder.Size = UDim2.new(1,0,0,1)
    self.TopBorder.BorderSizePixel = 0
    self.TopBorder.Name = "TopBorder"
    ThemeManager.ColorSync(self.TopBorder, "BackgroundColor3", Enum.StudioStyleGuideColor.RibbonTabTopBar, nil, true, nil, true)
    self.LeftBorder = Instance.new("Frame", self.TabFrame)
    self.LeftBorder.Size = UDim2.new(0,1,0,24)
    self.LeftBorder.BorderSizePixel = 0
    self.LeftBorder.Name = "LeftBorder"
    ThemeManager.ColorSync(self.LeftBorder, "BackgroundColor3", Enum.StudioStyleGuideColor.Border)
    self.RightBorder = Instance.new("Frame", self.TabFrame)
    self.RightBorder.Size = UDim2.new(0,1,0,24)
    self.RightBorder.Position = UDim2.new(1,0,0,0)
    self.RightBorder.BorderSizePixel = 0
    self.RightBorder.Name = "RightBorder"
    ThemeManager.ColorSync(self.RightBorder, "BackgroundColor3", Enum.StudioStyleGuideColor.Border)
    self.Content = Instance.new("Frame", self.TitlebarMenu.ContentContainers)
    self.Content.BackgroundTransparency = 1
    self.Content.Size = UDim2.new(1,0,1,0)
    self.Content.Name = self.ID
    self.TitlebarMenu:AddPage(self)
    if self.Arguments.Open then self.TitlebarMenu:SetActive(self.ID) else self:SetState(false) end
    GV.PluginPages[#GV.PluginPages+1] = self
    return self
end

return Page]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX913C0FEAD3834493B73E8493925ACA71">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">PluginWidget</string>
								<string name="ScriptGuid">{7cf86e66-6ef7-95b9-68de-c509f64f90c4}</string>
								<ProtectedString name="Source"><![CDATA[local GuiService = game:GetService("GuiService")
local Widget = {}
Widget.__index = Widget

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local plugin = GV.PluginObject
local util = require(GV.MiscDir.GUIUtil)
local InputManager = require(GV.ManagersDir.InputManager)
local GUIFrame = require(GV.FramesDir.GUIFrame)
local TitlebarMenu = require(GV.FramesDir.TitlebarMenu)
local InputField = require(GV.ObjectsDir.InputField)
local TextPrompt = require(GV.PromptsDir.TextPrompt)
local InputPrompt = require(GV.PromptsDir.InputPrompt)
local BackgroundFrame = require(GV.FramesDir.BackgroundFrame)
setmetatable(Widget,GUIFrame)
GV.PluginWidgets = {}
local Unnamed = 0

function Widget:Delete()
    local WidgetTitle = self.WidgetObject.Title
    local DeletePrompt = TextPrompt.new({Title = "Delete " .. WidgetTitle, Text = 'Are you sure you want to delete "' .. WidgetTitle .. '"?', Buttons = {"Yes", "No"}})
    DeletePrompt:Clicked(function(p)
        if p == 2 or p == 0 then return end
        if self.TitlebarMenu and #self.TitlebarMenu.Pages > 0 then
            local AvailibleWidgets = {}
            for _,v in pairs(GV.PluginWidgets)do
                if v.TitlebarMenu and v.WidgetObject.Title ~= WidgetTitle then AvailibleWidgets[#AvailibleWidgets+1] = {Name = v.WidgetObject.Title, Value = v} end
            end
            if #AvailibleWidgets < 1 then return end
            local TransferPrompt = InputPrompt.new({Title = "Transfer Pages", Text = "Where would you like to move the pages?", Buttons = {"OK", "Cancel"}, InputField = InputField.new({Value = AvailibleWidgets[1], Items = AvailibleWidgets, DisableEditing = true, NoFiltering = true, Unpausable = true})})
            TransferPrompt:Clicked(function(p2)
                if p2 == 2 then return end
                local NewWidget = TransferPrompt.InputField.Value
                if NewWidget == "" then return end
                for _, v in pairs(self.TitlebarMenu.Pages) do
                    NewWidget.TitlebarMenu:RecievePage(v)
                end
                self.WidgetObject:Destroy()
                table.remove(GV.PluginWidgets, self.Index)
                self = nil
            end)
            util.DumpGUI(TransferPrompt.Widget)
        else
            self.WidgetObject:Destroy()
            table.remove(GV.PluginWidgets, self.Index)
            self = nil
        end
    end)
end

function Widget:Rename()
    local NewTitlePrompt = InputPrompt.new({Title = "Rename " .. self.WidgetObject.Title, Text = "Type in a new name:", Buttons = {"OK", "Cancel"}, InputField = InputField.new({Placeholder = "New name", Text = self.WidgetObject.Title, NoDropdown = true, Unpausable = true})})
    NewTitlePrompt:Clicked(function(p)
        if p == 2 then return end
        self.WidgetObject.Title = NewTitlePrompt.Input.Text
    end)
end

-- ID, Title, Enabled, NoTitlebarMenu, DockState, OverrideRestore
function Widget.new(Arguments)
    local self = GUIFrame.new(Arguments)
    setmetatable(self, Widget)
    self.ID = self.Arguments.ID or game:GetService("HttpService"):GenerateGUID(false)
    local title = self.Arguments.Title
    if not title then
        title = self.Arguments.ID
        if not title then
            Unnamed += 1
            title = "Unnamed #" .. tostring(Unnamed)
        end
    end
    self.Arguments.DockState = self.Arguments.DockState or Enum.InitialDockState.Float
    -- really dumb but its gotta be a boolean
    if not self.Arguments.Enabled then self.Arguments.Enabled = false end
    if not self.Arguments.OverrideRestore then self.Arguments.OverrideRestore = false end
    self.WidgetObject = plugin:CreateDockWidgetPluginGui(self.ID, DockWidgetPluginGuiInfo.new(self.Arguments.DockState, self.Arguments.Enabled, self.Arguments.OverrideRestore, 300, 500, 50, 50))
    self.WidgetObject.Title = title
    self.BackgroundFrame = BackgroundFrame.new(nil, self.WidgetObject)
    self.InputFrame = Instance.new("Frame", self.WidgetObject)
    self.InputFrame.BackgroundTransparency = 1
    self.InputFrame.Size = UDim2.new(1,0,1,0)
    self.InputFrame.ZIndex = 100
    self.InputFrame.Name = "InputFrame"
    local FixPosition = false
    local FixPage = nil
    self.InputFrame.MouseMoved:Connect(function()
        if not FixPosition then return end
        FixPosition = false
        local MousePos = self.WidgetObject:GetRelativeMousePosition()
        FixPage.TabFrame.Position = UDim2.new(0,MousePos.X + FixPage.InitialX + self.TitlebarMenu.ScrollingMenu.CanvasPosition.X, 0,0)
        self.TitlebarMenu:BeingDragged(FixPage.ID)
        self.TitlebarMenu:FixPageLayout()
    end)
    InputManager.AddInput(self.InputFrame)
    if not self.Arguments.NoTitlebarMenu then self.TitlebarMenu = TitlebarMenu.new({ID = self.ID}, self.WidgetObject) end
    self.WidgetObject.PluginDragDropped:Connect(function()
        if(GV.SelectedPage and self.TitlebarMenu) then
            self.TitlebarMenu:RecievePage(GV.SelectedPage)
            FixPosition = true
            FixPage = GV.SelectedPage
            self.TitlebarMenu:SetActive(GV.SelectedPage.ID)
            GV.SelectedPage = nil
        end
    end)
    for _, v in pairs(GV.TitleBarButtons) do
        v:CreateCopy(self.TitlebarMenu)
    end
    self.Parent = self.WidgetObject
    self.Content = self.WidgetObject
    self.Index = #GV.PluginWidgets+1
    GV.PluginWidgets[self.Index] = self
    return self
end

return Widget]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX70161E5CCBD746C59635CA58458740DA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ScrollingFrame</string>
								<string name="ScriptGuid">{d65dc080-6417-addd-7c08-e361e2f2b9bc}</string>
								<ProtectedString name="Source"><![CDATA[local ScrollingFrame = {}
ScrollingFrame.__index = ScrollingFrame

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local GUIFrame = require(GV.FramesDir.GUIFrame)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
setmetatable(ScrollingFrame,GUIFrame)

ScrollingFrame.Images = {
    bottom = "http://www.roblox.com/asset/?id=9599518795",
    mid = "http://www.roblox.com/asset/?id=9599545837",
    top = "http://www.roblox.com/asset/?id=9599519108"
}

-- updaing the scrolling frame to fit window size based on element size
function ScrollingFrame:UpdateFrameSize()
    local ScrollbarVisibility = self.Content.AbsoluteWindowSize.Y < self.Content.AbsoluteCanvasSize.Y
    self.Content.CanvasSize = UDim2.new(0,0,0,self.Layout.AbsoluteContentSize.Y)
    self.ScrollbarBackground.Visible = ScrollbarVisibility
end

-- BarSize
function ScrollingFrame.new(Arguments, Parent)
    local self = GUIFrame.new(Arguments, Parent)
    setmetatable(self, ScrollingFrame)
    -- scroll bar background
    self.ScrollbarBackground = Instance.new("Frame", self.Parent)
    self.ScrollbarBackground.Size = UDim2.new(0,self.Arguments.BarSize or 15,1,0)
    self.ScrollbarBackground.Position = UDim2.new(1,-(self.Arguments.BarSize or 15),0,0)
    self.ScrollbarBackground.Name = "ScrollbarBackground"
    ThemeManager.ColorSync(self.ScrollbarBackground, "BackgroundColor3", Enum.StudioStyleGuideColor.ScrollBarBackground)

    -- scrolling frame
    self.Content = Instance.new("ScrollingFrame", self.Parent)
    self.Content.BackgroundTransparency = 1
    self.Content.Size = UDim2.new(1,0,1,0)
    self.Content.ScrollBarThickness = self.Arguments.BarSize or 15
    self.Content.BottomImage, self.Content.MidImage, self.Content.TopImage = self.Images.bottom, self.Images.mid, self.Images.top
    self.Content.ScrollingDirection = Enum.ScrollingDirection.Y
    self.Content.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
    self.Content.Name = "ScrollingFrame"
    self.Content.ZIndex = 2
    ThemeManager.ColorSync(self.Content, "ScrollBarImageColor3", Enum.StudioStyleGuideColor.ScrollBar)
    ThemeManager.ColorSync(self.Content, "BorderColor3", Enum.StudioStyleGuideColor.Border)

    -- list layout for later elements
    self.Layout = Instance.new("UIListLayout", self.Content)
    self.Layout.SortOrder = Enum.SortOrder.LayoutOrder
    self.Layout.HorizontalAlignment = Enum.HorizontalAlignment.Center

    -- updating the scrollingframe whenever things are added or the size of the widow is changed
    self.Layout.Changed:Connect(function(p)
        if p == "AbsoluteContentSize" then self:UpdateFrameSize() end
    end)
    self.Parent.Changed:Connect(function(p)
        if p == "AbsoluteSize" then self:UpdateFrameSize() end
    end)
    return self
end

return ScrollingFrame]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX6F2B54B5D1404742BE2F4D11DFE1FE4B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Section</string>
								<string name="ScriptGuid">{9d79beaf-d982-69f4-f998-f1f0731646c8}</string>
								<ProtectedString name="Source"><![CDATA[local Section = {}
Section.__index = Section

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local GUIFrame = require(GV.FramesDir.GUIFrame)
local TextboxMod = require(GV.ObjectsDir.Textbox)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
setmetatable(Section,GUIFrame)

Section.Images = {
    Open = "http://www.roblox.com/asset/?id=9666389442",
    Closed = "http://www.roblox.com/asset/?id=9666389853"
}

function Section:SetState(State)
    self.Open = State
    self.Content.Visible = self.Open
    if self.Open then self.CollapseImage.Image = self.Images.Open else self.CollapseImage.Image = self.Images.Closed end
end

function Section:Toggle()
    self:SetState(not self.Open)
end

-- Text, Open
function Section.new(Arguments, Parent)
    local self = GUIFrame.new(Arguments, Parent)
    setmetatable(self, Section)
    self.Open = self.Arguments.Open

    self.Collapse = Instance.new("Frame", self.Parent)
    self.Collapse.BackgroundTransparency = 1
    self.Collapse.Size = UDim2.new(1,0,0,0)
    self.Collapse.AutomaticSize = Enum.AutomaticSize.Y

    self.CollapseLayout = Instance.new("UIListLayout", self.Collapse)
    self.CollapseLayout.SortOrder = Enum.SortOrder.LayoutOrder
    self.CollapseLayout.FillDirection = Enum.FillDirection.Vertical
    self.CollapseLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    --self.CollapseLayout.Padding = UDim.new(0,5)

    self.Label = Instance.new("TextButton", self.Collapse)
    self.Label.Text = ""
    self.Label.Name = "Section Label"
    self.Label.Size = UDim2.new(2,0,0,25)
    self.Label.BorderSizePixel = 0
    ThemeManager.ColorSync(self.Label, "BackgroundColor3", Enum.StudioStyleGuideColor.Titlebar)
    self.Label.MouseButton1Click:Connect(function() self:Toggle() end)
    util.HoverIcon(self.Label, "rbxasset://SystemCursors/PointingHand")

    self.LabelFrame = Instance.new("Frame", self.Label)
    self.LabelFrame.AnchorPoint = Vector2.new(0.5,0)
    self.LabelFrame.Position = UDim2.new(0.5,0,0,0)
    self.LabelFrame.Size = UDim2.new(0.5,0,0,25)
    self.LabelFrame.BackgroundTransparency = 1
    
    self.LabelLayout = Instance.new("UIListLayout", self.LabelFrame)
    self.LabelLayout.SortOrder = Enum.SortOrder.LayoutOrder
    self.LabelLayout.FillDirection = Enum.FillDirection.Horizontal

    self.CollapseImageFrame = Instance.new("Frame", self.LabelFrame)
    self.CollapseImageFrame.Size = UDim2.new(0,25,0,25)
    self.CollapseImageFrame.BackgroundTransparency = 1

    self.CollapseTextboxFrame = Instance.new("Frame", self.LabelFrame)
    self.CollapseTextboxFrame.Size = UDim2.new(1,-25,0,25)
    self.CollapseTextboxFrame.BackgroundTransparency = 1

    self.CollapseImage = Instance.new("ImageLabel", self.CollapseImageFrame)
    self.CollapseImage.BackgroundTransparency = 1
    self.CollapseImage.AnchorPoint = Vector2.new(0.5,0.5)
    self.CollapseImage.Position = UDim2.new(0.5,0,0.5,0)
    self.CollapseImage.Size = UDim2.new(0,15,0,15)
    ThemeManager.ColorSync(self.CollapseImage, "ImageColor3", Enum.StudioStyleGuideColor.MainText)

    local Textbox = self.Arguments.Textbox or self.Arguments.Text
    if type(Textbox) == "string" then
        self.TextboxTable = TextboxMod.new({Text = Textbox, Font = Enum.Font.SourceSansBold, Alignment = Enum.TextXAlignment.Left, TextSize = 15}, self.CollapseTextboxFrame)
    else
        self.TextboxTable = Textbox
        Textbox:Move(self.CollapseTextboxFrame, true)
    end
    self.TextboxTable.Arguments.Unpausable = true
    self.Textbox = self.TextboxTable.Textbox
    self.Collapse.Name = "Section - " .. self.Textbox.Text
    self.Textbox.AnchorPoint = Vector2.new(0,0.5)
    self.Textbox.Position = UDim2.new(0,0,0.5,0)

    self.Content = Instance.new("Frame", self.Collapse)
    self.Content.Size = UDim2.new(1,-15,0,0)
    self.Content.BackgroundTransparency = 1
    self.Content.Visible = self.Open
    self.Content.Name = "Contents"

    self.Layout = Instance.new("UIListLayout", self.Content)
    self.Layout.SortOrder = Enum.SortOrder.LayoutOrder
    self.Layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    self:SetState(self.Arguments.Open)

    local function syncContentSize()
        self.Content.Size = UDim2.new(1, -15, 0, self.Layout.AbsoluteContentSize.Y);
    end
    syncContentSize()
    self.Layout.Changed:Connect(function(p)
        if p == "AbsoluteContentSize" then
            syncContentSize()
        end
    end)

    return self
end

return Section]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX8BAC58DF64C646D495E42E9EA78668C9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TitlebarMenu</string>
								<string name="ScriptGuid">{6676e745-d134-1729-fdd8-32140503ab70}</string>
								<ProtectedString name="Source"><![CDATA[local StarterPlayer = game:GetService("StarterPlayer")
local TitlebarMenu = {}
TitlebarMenu.__index = TitlebarMenu
local GV = require(script.Parent.Parent.PluginGlobalVariables)
local GUIFrame = require(GV.FramesDir.GUIFrame)
local util = require(GV.MiscDir.GUIUtil)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
setmetatable(TitlebarMenu,GUIFrame)
GV.PluginTitlebarMenus = {}

function TitlebarMenu:RecievePage(Page)
    Page.TabFrame.Parent = self.TabContainer
    Page.Content.Parent = self.ContentContainers
    Page.TitlebarMenu = self
    Page.InsideWidget = true
    Page.Parent = self.TitlebarMenu
    self:AddPage(Page)
end

function TitlebarMenu:GetIDIndex(ID)
    for i,v in pairs(self.Pages) do if v.ID == ID then return i end end
end

function TitlebarMenu:GetIDTab(ID)
    return self.Pages[self:GetIDIndex(ID)]
end

function TitlebarMenu:AddPage(Page)
    self:FixPageLayout()
    if #self.Pages > 0 then
        local LatestPage = self.Pages[#self.Pages]
        Page.TabFrame.Position = UDim2.new(0,LatestPage.TabFrame.Position.X.Offset + LatestPage.TabFrame.Size.X.Offset,0,0)
    else
        Page.TabFrame.Position = UDim2.new(0,0,0,0)
    end
    self.ScrollingMenu.CanvasSize = UDim2.new(0,Page.TabFrame.Position.X.Offset + Page.TabFrame.Size.X.Offset,0,0)
    self.Pages[#self.Pages+1] = Page
end

function TitlebarMenu:RemovePage(Page)
    table.remove(self.Pages, self:GetIDIndex(Page.ID))
    self.ScrollingMenu.CanvasSize = UDim2.new(0,self.ScrollingMenu.CanvasSize.Width.Offset - Page.TabFrame.Size.X.Offset,0,0)
    self:FixPageLayout()
end

function TitlebarMenu:SetActive(ID)
    for _, v in pairs(self.Pages) do
        v:SetState(v.ID == ID)
    end
end

function TitlebarMenu:FixPageLayout(IgnoreID)
    local PreviousPageSize = 0
    for _, v in pairs(self.Pages) do
        if IgnoreID ~= v.ID then
            v.TabFrame.Position = UDim2.new(0,PreviousPageSize,0,0)
        end
        PreviousPageSize += v.TabFrame.Size.X.Offset
    end
end

function TitlebarMenu:MovePage(ID, Index, IgnoreID)
    local PageIndex = self:GetIDIndex(ID)
    if PageIndex == Index then return end
    local Page = self.Pages[PageIndex]
    table.remove(self.Pages, PageIndex)
    table.insert(self.Pages, Index, Page)
    if IgnoreID then self:FixPageLayout(ID) end
end

function TitlebarMenu:BeingDragged(ID)
    local tab = self:GetIDTab(ID)
    local xpos = tab.TabFrame.Position.X.Offset + tab.TabFrame.Size.X.Offset / 2
    for i, v in pairs(self.Pages) do
        if v.ID ~=ID and xpos >= v.TabFrame.Position.X.Offset and xpos < v.TabFrame.Position.X.Offset + v.TabFrame.Size.X.Offset then
            self:MovePage(ID, i, true)
        end
    end
end
-- ID
function TitlebarMenu.new(Arguments, Parent)
    local self = GUIFrame.new(Arguments, Parent)
    self.ID = self.Arguments.ID or game:GetService("HttpService"):GenerateGUID(false)
    setmetatable(self,TitlebarMenu)
    self.TitlebarMenu = Instance.new("Frame", self.Parent)
    self.TitlebarMenu.Name = "TitlebarMenu"
    self.TitlebarMenu.Size = UDim2.new(1,0,0,24)
    ThemeManager.ColorSync(self.TitlebarMenu, "BackgroundColor3", Enum.StudioStyleGuideColor.Titlebar,nil,nil,nil,true)
    self.TitlebarMenu.BorderSizePixel = 0
    self.ButtonsFrame = Instance.new("Frame", self.TitlebarMenu)
    self.ButtonsFrame.Size = UDim2.new(0,0,0,24)
    self.ButtonsFrame.ZIndex = 3
    ThemeManager.ColorSync(self.ButtonsFrame, "BackgroundColor3", Enum.StudioStyleGuideColor.Titlebar,nil,nil,nil,true)
    self.ButtonsFrame.BorderSizePixel = 0
    self.ButtonsFrame.Name = "ButtonsFrame"
    local ButtonsFrameBorder = Instance.new("Frame", self.ButtonsFrame)
    ButtonsFrameBorder.Position = UDim2.new(0,0,1,-1)
    ButtonsFrameBorder.Size = UDim2.new(1,0,0,1)
    ButtonsFrameBorder.BorderSizePixel = 0
    ThemeManager.ColorSync(ButtonsFrameBorder, "BackgroundColor3", Enum.StudioStyleGuideColor.Border,nil,nil,nil,true)
    ButtonsFrameBorder.Name = "Border"
    ButtonsFrameBorder.ZIndex = 5
    self.ButtonContainer = Instance.new("Frame", self.ButtonsFrame)
    self.ButtonContainer.BackgroundTransparency = 1
    self.ButtonContainer.BorderSizePixel = 0
    self.ButtonContainer.Size = UDim2.new(1,0,1,0)
    self.ButtonContainer.Name = "ButtonContainer"
    local ButtonContainerLayout = Instance.new("UIListLayout", self.ButtonContainer)
    ButtonContainerLayout.FillDirection = Enum.FillDirection.Horizontal
    ButtonContainerLayout.SortOrder = Enum.SortOrder.LayoutOrder
    self.ScrollingMenu = Instance.new("ScrollingFrame", self.TitlebarMenu)
    self.ScrollingMenu.BackgroundTransparency = 1
    self.ScrollingMenu.Position = UDim2.new(1,0,0,0)
    self.ScrollingMenu.AnchorPoint = Vector2.new(1,0)
    self.ScrollingMenu.Size = UDim2.new(1,0,1,0)
    self.ScrollingMenu.CanvasSize = UDim2.new(0,0,0,0)
    self.ScrollingMenu.ScrollBarThickness = 0
    self.ScrollingMenu.ScrollingDirection = Enum.ScrollingDirection.X
    self.ScrollingMenu.ZIndex = 2
    self.ScrollingMenu.ClipsDescendants = false
    ButtonContainerLayout.Changed:Connect(function(p)
        if p ~= "AbsoluteContentSize" then return end
        self.ButtonsFrame.Size = UDim2.new(0,ButtonContainerLayout.AbsoluteContentSize.X, 1,0)
        self.ScrollingMenu.Size = UDim2.new(1,-ButtonContainerLayout.AbsoluteContentSize.X,1,0)
    end)
    self.TabContainer = Instance.new("Frame", self.ScrollingMenu)
    self.TabContainer.BackgroundTransparency = 1
    self.TabContainer.Size = UDim2.new(1,0,1,0)
    self.TabContainer.ZIndex = 2
    self.TabContainer.Name = "TabContainer"
    --local TabContainerPadding = Instance.new("UIPadding", self.TabContainer)
    --TabContainerPadding.PaddingLeft, TabContainerPadding.PaddingRight = UDim.new(0,5), UDim.new(0,5)
    local TabContainerBorder = Instance.new("Frame", self.TitlebarMenu)
    TabContainerBorder.Name = "Border"
    TabContainerBorder.Position = UDim2.new(0,0,1,-1)
    TabContainerBorder.Size = UDim2.new(1,0,0,1)
    TabContainerBorder.BorderSizePixel = 0
    TabContainerBorder.ZIndex = 2
    ThemeManager.ColorSync(TabContainerBorder, "BackgroundColor3", Enum.StudioStyleGuideColor.Border)
    self.ContentContainers = Instance.new("Frame", self.Parent)
    self.ContentContainers.Name = "Content"
    self.ContentContainers.BackgroundTransparency = 1
    self.ContentContainers.Position = UDim2.new(0,0,0,24)
    self.ContentContainers.Size = UDim2.new(1,0,1,-24)
    self.Pages = {}
    self.Content = self.Parent
    GV.PluginTitlebarMenus[#GV.PluginTitlebarMenus+1] = self
    return self
end

return TitlebarMenu]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX376CAA8C97334434BFAB99680C64CCB9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">GUIElement</string>
							<string name="ScriptGuid">{0e29a095-a497-3c9c-6234-0222622bfa2b}</string>
							<ProtectedString name="Source"><![CDATA[local GUIElement = {}
GUIElement.__index = GUIElement

local GV = require(script.Parent.PluginGlobalVariables)

function GUIElement.new(Arguments, Parent)
    local self = {}
    setmetatable(self,GUIElement)
    self.Arguments = Arguments or {}
    self.Parent = Parent
    return self
end

return GUIElement]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX4A2C2143F3394A7394995D41C2A1E576">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Managers</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX8F510CAC5C5F45568EB8815CFEF67CC0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">EventManager</string>
								<string name="ScriptGuid">{3a790e43-263c-47cf-540c-e9349acb4acb}</string>
								<ProtectedString name="Source"><![CDATA[local m = {}

local GV = require(script.Parent.Parent.PluginGlobalVariables)
m.EventList = {}

function m.AddConnection(Connection, func)
    m.EventList[#m.EventList+1] = Connection:Connect(func)
end

GV.PluginObject.Unloading:Connect(function()
    for _, v in pairs(m.EventList) do
        v:Disconnect()
    end
end)

return m]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX8218E9382CD845739D20F535C54999D4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">InputManager</string>
								<string name="ScriptGuid">{2b8f6f39-0278-0ecc-8d3c-0e495aa234d3}</string>
								<ProtectedString name="Source"><![CDATA[local m = {}

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local EventManager = require(GV.ManagersDir.EventManager)

m.InputFieldEvents = {}
m.InputFrames = {}
function m.AddInputEvent(Event, func)
    m.InputFieldEvents[#m.InputFieldEvents+1] = {Event, func}
    for _, v in pairs(m.InputFrames) do
        EventManager.AddConnection(v[Event], func)
    end
end

function m.AddInput(Frame)
    m.InputFrames[#m.InputFrames + 1] = Frame
    for _, v in pairs(m.InputFieldEvents) do
        EventManager.AddConnection(Frame[v[1]], v[2])
    end
end

return m]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4A550DFD1AE0422DA755D2EDDE8BFFE8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">KeybindManager</string>
								<string name="ScriptGuid">{d4d7678c-adc6-aa6c-160a-f3ca93a1a427}</string>
								<ProtectedString name="Source"><![CDATA[local InputService = game:GetService("UserInputService")
local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local InputManager = require(GV.ManagersDir.InputManager)
local EventManager = require(GV.ManagersDir.EventManager)

local m = {}

m.Keys = {
    LeftControl = "Ctrl", LeftAlt = "Alt", LeftShift = "Shift", QuotedDouble = '"', Hash = "#", Dollar = "$" , Percent = "%", Ampersand = "&", Quote = "'", LeftParenthesis = "(", RightParenthesis = ")", Asterisk = "*",Plus = "+", Comma = ",", Minus = "-", Period = ".", Slash = "/", Zero = "0", One = "1", Two = "2", Three = "3", Four = "4", Five = "5", Six = "6", Seven = "7", Eight = "8", Nine = "9", Colon = ":", Semicolon = ";", LessThan = "<", Equals = "=", GreaterThan = ">", Question = "?", At = "@", LeftBracket = "[", BackSlash = "\\", RightBracket = "]", Caret = "^", Underscore = "_", Backquote = "`", LeftCurly = "{", Pipe = "|", RightCurly = "}", Tilde = "~", Delete = "Del", Up = "", Down = "", Right = "", Left = "", PageUp = "PgUp", PageDown = "PgDown", Euro = ""
}

function m.FilterKeyCode(KeycodeName)
    if KeycodeName == "RightControl" then KeycodeName = "LeftControl"
    elseif KeycodeName == "RightAlt" then KeycodeName = "LeftAlt"
    elseif KeycodeName == "RightShift" then KeycodeName = "LeftShift" end
    return KeycodeName
end

function m.RecallKeyName(KeycodeName)
    KeycodeName = m.FilterKeyCode(KeycodeName)
    KeycodeName = KeycodeName:gsub("Keypad", "")
    if m.Keys[KeycodeName] then
        return m.Keys[KeycodeName]
    end
    return KeycodeName
end

function m.GenerateKeybindName(Keybind)
    if type(Keybind) == "string" then Keybind = {Keybind} end
    if #Keybind < 1 then return "" end
    local GeneratedName = m.RecallKeyName(Keybind[1])
    for i, v in pairs(Keybind) do
        if i ~= 1 then
            GeneratedName = GeneratedName .. "+" .. m.RecallKeyName(v)
        end
    end
    return GeneratedName
end

function m.GenerateKeybindList(Keybinds)
    if type(Keybinds) == "string" then Keybinds = {{Keybinds}} end
    if #Keybinds < 1 then return "" end
    local GeneratedList = m.GenerateKeybindName(Keybinds[1])
    for i, v in pairs(Keybinds) do
        if i ~= 1 and #v > 0 then
            GeneratedList = GeneratedList .. ", " .. m.GenerateKeybindName(v)
        end
    end
    return GeneratedList
end



m.Keybinds = {}
m.ActiveKeybinds = {}

function m.UpdateKeybinds(Name, Args)
    m.Keybinds[Name] = Args
end

function m.TableContains(Table, Contains)
    for _, v in pairs(Table) do if v == Contains then return true end end
    return false
end

function m.TableContainsTable(Table1, Table2)
    if #Table1 < #Table2 or #Table2 < 1 then return false end
    for _, v in pairs(Table2) do
        if not m.TableContains(Table1, v) then
            return false
        end
    end
    return true
end

function m.CheckKeybinds(Keys, Holdable, KeycodeName)
    local ContainsKeybind = false
    for _, Input in pairs(m.Keybinds) do
        ContainsKeybind = false
        for _, Keybind in pairs(Input.Keybinds) do
            if not Holdable and not Input.Holdable then
                if #Keys > 0 and #Keys == #Keybind and m.TableContainsTable(Keys, Keybind) then
                    ContainsKeybind = true
                    break
                end
            end
            if Holdable and Input.Holdable and m.TableContainsTable(Keys, Keybind) and KeycodeName and m.TableContains(Keybind, KeycodeName) then
                ContainsKeybind = true
            end
        end
        if not ContainsKeybind then continue end
        m.ActiveKeybinds[#m.ActiveKeybinds+1] = Input
        if Input.PressedAction then Input.PressedAction() end
    end
end

function m.CheckActive(KeycodeName)
    local IndexShift = 0
    local ContainsRemoved = false
    for Index, Input in pairs(m.ActiveKeybinds) do
        if Input.Holdable and KeycodeName then
            ContainsRemoved = false
            for _, Keybind in pairs(Input.Keybinds) do
                if m.TableContains(Keybind, KeycodeName) then
                    ContainsRemoved = true
                    break
                end
            end
            if not ContainsRemoved then
                continue
            end
        end
        if Input.ReleasedAction then Input.ReleasedAction() end
        table.remove(m.ActiveKeybinds, Index - IndexShift)
        IndexShift += 1
    end

end


m.FocusFunction = {}
m.FocusedInputField = {}

function m.FocusInputField(Name, selfobj, EditBind, RemoveBind, Unfocus)
    if m.FocusedInputField.Name and m.FocusedInputField.Name ~= Name then m.Unfocus() end
    m.FocusedInputField = {Name = Name, Unrestricted = selfobj.Unrestricted, EditBind = EditBind, RemoveBind = RemoveBind, Unfocus = Unfocus}
    for i, v in pairs(m.FocusedInputField) do
        if type(v) == "function" then
            m.FocusFunction[i] = function(...)
                return v(selfobj, ...)
            end
        end
    end
end

function m.Unfocus(ForceClose)
    if m.FocusFunction.Unfocus and m.FocusFunction.Unfocus(ForceClose) then
        m.FocusFunction = {}
    end
end


--Keys being pressed down
local CurrentKeys = {}
local CompleteBind = false

local function InputBegan(p)
    if p.UserInputType == Enum.UserInputType.MouseButton1 or p.UserInputType == Enum.UserInputType.MouseButton2 then m.Unfocus() return end
    if p.UserInputType ~= Enum.UserInputType.Keyboard then return end
    local KeycodeName = m.FilterKeyCode(p.KeyCode.Name)
    local KeyName = m.RecallKeyName(p.KeyCode.Name)
    for _, v in pairs(CurrentKeys) do
        if v == KeycodeName then return end
    end
    m.CheckActive(KeycodeName)
    if KeyName == "Backspace" and m.FocusFunction.RemoveBind then m.FocusFunction.RemoveBind() return end
    if KeyName == "Escape" and m.FocusFunction.Unfocus then m.Unfocus() return end
    CurrentKeys[#CurrentKeys+1] = KeycodeName
    m.CheckKeybinds(CurrentKeys, true, KeycodeName)
    if not m.FocusFunction.EditBind or not m.FocusedInputField.Unrestricted then
        if CompleteBind then return end
        if KeyName ~= "Ctrl" and KeyName ~= "Alt" and KeyName ~= "Shift" then
            CompleteBind = true
            if m.FocusFunction.EditBind then
                m.FocusFunction.EditBind(util.CopyTable(CurrentKeys), true)
                return
            end
        end
    end
    m.CheckKeybinds(CurrentKeys)
    if m.FocusFunction.EditBind then m.FocusFunction.EditBind(util.CopyTable(CurrentKeys), false) end
end

local function InputEnded(p)
    if p.UserInputType ~= Enum.UserInputType.Keyboard then return end
    local KeycodeName = m.FilterKeyCode(p.KeyCode.Name)
    local KeyName = m.RecallKeyName(KeycodeName)
    local IndexShift = 0;
    m.CheckActive(KeycodeName)
    for i, v in pairs(CurrentKeys) do
        if v == KeycodeName then
            if not m.FocusedInputField.Unrestricted then
                if KeyName ~= "Ctrl" and KeyName ~= "Alt" and KeyName ~= "Shift" then
                    CompleteBind = false
                end
            elseif (not CompleteBind) or #CurrentKeys ~= 1 then
                if m.FocusFunction.EditBind and not CompleteBind then m.FocusFunction.EditBind(util.CopyTable(CurrentKeys), true)end
                CompleteBind = true
                table.remove(CurrentKeys, i - IndexShift)
                if #CurrentKeys == 0 then CompleteBind = false end
                return
            else
                CompleteBind = false
            end
            table.remove(CurrentKeys, i - IndexShift)
            IndexShift += 1
        end
    end
    if m.FocusFunction.EditBind and not CompleteBind then m.FocusFunction.EditBind(util.CopyTable(CurrentKeys), false) end
end


InputManager.AddInputEvent("InputBegan", InputBegan)
InputManager.AddInputEvent("InputEnded", InputEnded)
InputManager.AddInputEvent("MouseLeave", m.Unfocus)
EventManager.AddConnection(InputService.InputBegan, InputBegan)
EventManager.AddConnection(InputService.InputEnded, InputEnded)

return m]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC27060397EC74076B2F0D85666BFA8E5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LayoutManager</string>
								<string name="ScriptGuid">{5da41922-5da5-2e15-0746-8fb4fc37905c}</string>
								<ProtectedString name="Source"><![CDATA[local m = {}
local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)

function m.SearchForID(ID, Table)
    for i,v in pairs(Table) do
        if v.ID == ID then return {i,v} end
    end
    return {nil,nil}
end

function m.GetLayout()
    local layout = {Widgets = {}, Pages = {}}
    for _, Widget in pairs(GV.PluginWidgets) do
        local WidgetDesc = {
            ID = Widget.ID,
            Title = Widget.WidgetObject.Title
        }
        layout.Widgets[#layout.Widgets+1] = WidgetDesc
    end
    for _, Page in pairs(GV.PluginPages) do
        local PageDesc = {
            ID = Page.ID,
            MenuID = Page.TitlebarMenu.ID
        }
        layout.Pages[#layout.Pages+1] = PageDesc
    end
    return layout
end

function m.RecallLayout(layout)
    for _, Widget in pairs(layout.Widgets) do
        local WidgetTable = m.SearchForID(Widget.ID, GV.PluginWidgets)[2]
        if not WidgetTable then
            WidgetTable = require(GV.FramesDir.PluginWidget).new({ID = Widget.ID, Title = Widget.Title, Enabled = true})
        end
        WidgetTable.WidgetObject.Title = Widget.Title
    end
    for _, Page in pairs(layout.Pages) do
        local PageTable = m.SearchForID(Page.ID, GV.PluginPages)[2]
        if PageTable then
            if PageTable.TitlebarMenu.ID ~= Page.MenuID then
                local NewMenu = m.SearchForID(Page.MenuID, GV.PluginWidgets)[2]
                if NewMenu then
                    PageTable.TitlebarMenu:RemovePage(PageTable)
                    NewMenu.TitlebarMenu:RecievePage(PageTable)
                end
            end
        end
    end
    for i, Widget in pairs(GV.PluginWidgets) do
        if not m.SearchForID(Widget.ID, layout.Widgets)[2] then
            Widget.WidgetObject:Destroy()
            Widget = nil
            GV.PluginWidgets[i] = nil
        end
    end
end

function m.SaveLayout(layout)
    layout = layout or m.GetLayout()
    GV.PluginObject:SetSetting(GV.PluginID.."PreviousGUIState", layout)
end

function m.RecallSave()
    m.DefaultLayout = m.GetLayout()
    m.RecallLayout(GV.PluginObject:GetSetting(GV.PluginID.."PreviousGUIState"))
end

function m.ResetLayout()
    m.RecallLayout(m.DefaultLayout)
end

GV.PluginObject.Unloading:Connect(function()
    m.SaveLayout()
end)

return m]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX393A9EDFC5574AF0AE870AB5E29B8F56">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ThemeManager</string>
								<string name="ScriptGuid">{c0b4254f-d376-61a7-2abe-d2ff09009cc7}</string>
								<ProtectedString name="Source"><![CDATA[local m = {}

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local EventManager = require(GV.ManagersDir.EventManager)
local util = require(GV.MiscDir.GUIUtil)

-- syncs colors with studio theme
local syncedelements = {}
m.DefaultAccentColor = Color3.fromRGB(53, 181, 255)
m.DefaultThemeColor = Color3.new(0.5,0.5,0.5)

m.PreinstalledThemes = {{Name = "Default Theme", Theme = util.Color3ToTable(m.DefaultThemeColor), Accent = util.Color3ToTable(m.DefaultAccentColor)}}

function m.ColorSync(element, property, enum, enum2, accent, accenttheme, ignoretheme)
    syncedelements[#syncedelements + 1] = {element, property, enum, enum2, accent, accenttheme, ignoretheme}
    m.MatchColor(element, property, enum, enum2, accent, accenttheme, ignoretheme)
end

function m.MatchColor(element, property, enum, enum2, useaccent, accenttheme, ignoretheme)
    local Theme = settings().Studio.Theme
    if useaccent and (((accenttheme) and accenttheme == tostring(Theme)) or not accenttheme) then
        element[property] = m.CurrentAccent
    else
        local ThemeColor = Theme:GetColor(enum, enum2)
        if not ignoretheme then
            element[property] = util.AddColor(util.MulitplyColor(util.SubColor(Color3.new(1,1,1), util.MulitplyColor(m.CurrentTheme, Color3.new(2,2,2))), util.MulitplyColor(ThemeColor, ThemeColor)), util.MulitplyColor(util.MulitplyColor(ThemeColor, m.CurrentTheme), Color3.new(2,2,2)))
        else
            element[property] = ThemeColor
        end
    end
end

function m.ReloadTheme(theme, accent)
    m.CurrentTheme = theme or m.CurrentTheme
    m.CurrentAccent = accent or m.CurrentAccent
    for _, v in pairs(syncedelements) do
        m.MatchColor(v[1], v[2], v[3], v[4], v[5], v[6], v[7])
    end
end

function m.UpdateTheme(theme,accent)
    m.ThemeColor = theme or m.CurrentTheme
    m.AccentColor = accent or m.CurrentAccent
    m.ReloadTheme(m.ThemeColor, m.AccentColor)
end

EventManager.AddConnection(settings().Studio.ThemeChanged, function()
    m.ReloadTheme(m.CurrentTheme, m.CurrentAccent)
end)

local LatestThemeSave = GV.PluginObject:GetSetting(GV.PluginID.."PreviousPluginGUITheme") or {Theme = util.Color3ToTable(m.DefaultThemeColor), Accent = util.Color3ToTable(m.DefaultAccentColor)}
m.AccentColor = util.TableToColor3(LatestThemeSave.Accent)
m.ThemeColor = util.TableToColor3(LatestThemeSave.Theme)
m.CurrentTheme = m.ThemeColor
m.CurrentAccent = m.AccentColor

GV.PluginObject.Unloading:Connect(function()
    GV.PluginObject:SetSetting(GV.PluginID.."PreviousPluginGUITheme", {Theme = util.Color3ToTable(m.ThemeColor), Accent = util.Color3ToTable(m.AccentColor)})
end)

return m]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX685619A8899641AFA617DD175D600617">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Misc</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXE8BEF33033DA40709B639EE3E1E8558F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">GUIUtil</string>
								<string name="ScriptGuid">{6cb8bdb2-c709-b407-5e42-b0052298a5bc}</string>
								<ProtectedString name="Source"><![CDATA[local m = {}
local GV = require(script.Parent.Parent.PluginGlobalVariables)

-- dumps the gui into workspace for debugging
function m.DumpGUI(parent)
    local StarterGUI = game:GetService("StarterGui")
    local temp = Instance.new("ScreenGui", StarterGUI)
    if StarterGUI:FindFirstChild("Dump") then
        StarterGUI.Dump.Parent = nil
    end
    temp.Name = "Dump"
    for _, i in pairs(parent:GetChildren()) do
        i:Clone().Parent = temp
    end
end

function m.AppendTable(table,newtable)
    local fulltable = table
    for i, v in pairs(newtable) do fulltable[i] = v end
    return fulltable
end

function m.DumpTable(Table, Step)
    Step = Step or 1
    if type(Table) == "table"then
        local result = "{\n" .. string.rep(":", Step)
        for i, v in pairs(Table) do
            result = result .. i .." = " .. m.DumpTable(v, Step+1) .. ","
        end
        return result .. "\n".. string.rep(":", Step-1) .. "}"
    else
        return tostring(Table)
    end
end

function m.HoverIcon(element, icon)
    icon = icon or "rbxasset://SystemCursors/PointingHand"
    element.MouseMoved:Connect(function()
        GV.PluginObject:GetMouse().Icon = icon
    end)
    element.MouseLeave:Connect(function()
        task.wait(0)
        GV.PluginObject:GetMouse().Icon = "rbxasset://SystemCursors/Arrow"
    end)
end

function m.CopyTable(t)
    local newt = {}
    for i,v in pairs(t) do
        newt[i] = v
    end
    return newt
end

function m.GetScale(Scale)
    if typeof(Scale) == "UDim" then
        return Scale
    elseif typeof(Scale) == "number" then
        return UDim.new(Scale,0)
    else
        return nil
    end
end

function m.RoundNumber(number, factor)
    if factor == 0 then return number else return math.floor(number/factor+0.5)*factor end
end

local UnpauseList = {}
function m.PauseAll()
    if #UnpauseList > 0 then return end
    for _,v in pairs(GV.ObjectList) do
        if v and v.SetDisabled and not v.Disabled and not v.Arguments.Unpausable then
            v:SetDisabled(true)
            UnpauseList[#UnpauseList+1] = v
        end
    end
end

function m.UnpauseAll()
    for _,v in pairs(UnpauseList) do
        v:SetDisabled(false)
    end
    UnpauseList = {}
end

function m.AddColor(c1, c2)
    return Color3.new(c1.R + c2.R, c1.G + c2.G, c1.B + c2.B)
end
function m.SubColor(c1, c2)
    return Color3.new(c1.R - c2.R, c1.G - c2.G, c1.B - c2.B)
end
function m.MulitplyColor(c1,c2)
    return Color3.new(c1.R * c2.R, c1.G * c2.G, c1.B * c2.B)
end

function m.Color3ToText(color)
    return "[" .. m.RoundNumber(color.R*255, 1) .. ", " .. m.RoundNumber(color.G*255, 1) .. ", " .. m.RoundNumber(color.B*255, 1) .. "]"
end

function m.TextToColor3(text)
    local numbers = {}
    for i in text:gmatch("[%.%d]+") do
        numbers[#numbers+1] = tonumber(i)
        if #numbers == 3 then break end
    end
    return Color3.fromRGB(numbers[1] or 0, numbers[2] or 0, numbers[3] or 0)
end

function m.Color3ToTable(color)
    return {R = color.R, G = color.G, B = color.B}
end

function m.TableToColor3(table)
    return Color3.new(table.R, table.G, table.B)
end

return m]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX2A67314DEBD34E0EA8B83EBD28AEEB98">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Objects</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXDFA5EC26D8114861A7D458509A072009">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Button</string>
								<string name="ScriptGuid">{8035d8a2-62f4-4bec-ef9a-ac33091463a0}</string>
								<ProtectedString name="Source"><![CDATA[local Button = {}
Button.__index = Button

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
local TextboxMod = require(GV.ObjectsDir.Textbox)
local GUIObject = require(GV.ObjectsDir.GUIObject)
setmetatable(Button,GUIObject)

Button.Images = {
    border = "http://www.roblox.com/asset/?id=10460485555",
    bg = "http://www.roblox.com/asset/?id=10460051857",
    selected = "http://www.roblox.com/asset/?id=10460676787"
}

function Button:SetDisabled(State)
    self.Disabled = State
    if self.Disabled then
        self.CursorIcon = "rbxasset://SystemCursors/Forbidden"
        self.Button.ImageTransparency, self.Textbox.TextTransparency = 0.5, 0.5
    else
        self.CursorIcon = "rbxasset://SystemCursors/PointingHand"
        self.Button.ImageTransparency, self.Textbox.TextTransparency = 0, 0
    end
end

function Button:ToggleDisable()
    self:SetDisabled(not self.Disabled)
end

function Button:Clicked(func)
    self.Action = func
end

function Button:Pressed(func)
    self.PressedAction = func
end

function Button:Released(func)
    self.ReleasedAction = func
end

-- Text/Textbox, ButtonSize, Disabled
function Button.new(Arguments, Parent)
    local self = GUIObject.new(Arguments, Parent)
    setmetatable(self,Button)
    self.TextboxTable = nil
    -- creating a frame to hold the button
    self.ButtonFrame = Instance.new("Frame", self.Parent)
    self.ButtonFrame.BackgroundTransparency = 1
    self.ButtonFrame.Name = "ButtonFrame"
    self.ButtonFrame.Size = UDim2.new(1,0,1,0)

    self.Button = Instance.new("ImageButton", self.ButtonFrame)

    -- set up a textbox for the button
    local Textbox = self.Arguments.Textbox or self.Arguments.Text
    if type(Textbox) == "string" then
        self.TextboxTable = TextboxMod.new({Text = Textbox}, self.Button)
    else
        self.TextboxTable = Textbox
        Textbox:Move(self.Button, true)
    end
    self.Textbox = self.TextboxTable.Textbox
    self.Textbox.ZIndex = 1

    local Size = util.GetScale(self.Arguments.ButtonSize)
    if Size then self.Button.Size = UDim2.new(Size.Scale,Size.Offset,1,0)
    else
        local function sync()
            self.Button.Size = UDim2.new(0,self.Textbox.TextBounds.X+1.5*self.Textbox.TextSize, 1, 0)
        end
        self.Textbox.Changed:Connect(function(p)
            if p == "TextBounds" then sync() end
        end)
    end
    self.Button.Position = UDim2.new(0.5, 0, 0, 0)
    self.Button.AnchorPoint = Vector2.new(0.5,0)
    self.Button.BackgroundTransparency = 1
    self.Button.Image = self.Images.border
    ThemeManager.ColorSync(self.Button, "ImageColor3", Enum.StudioStyleGuideColor.DialogButtonBorder)
    self.Button.ScaleType = Enum.ScaleType.Slice
    self.Button.SliceCenter = Rect.new(7,7,156,36)
    self.Button.Name = "Button"

    self.ButtonBackground = Instance.new("ImageLabel", self.Button)
    self.ButtonBackground.Name = "ButtonBackground"
    self.ButtonBackground.BackgroundTransparency = 1
    self.ButtonBackground.Size = UDim2.new(1,0,1,0)
    self.ButtonBackground.Image = self.Images.bg
    ThemeManager.ColorSync(self.ButtonBackground, "ImageColor3", Enum.StudioStyleGuideColor.Button)
    self.ButtonBackground.ScaleType = Enum.ScaleType.Slice
    self.ButtonBackground.SliceCenter = Rect.new(7,7,156,36)
    self.ButtonBackground.ZIndex = 0

    self.Toggleable = false
    local Pressed = false
    self.Button.MouseMoved:Connect(function()
        GV.PluginObject:GetMouse().Icon = self.CursorIcon
        if self.Disabled or Pressed or self.Toggleable then return end
        ThemeManager.ColorSync(self.Button, "ImageColor3", Enum.StudioStyleGuideColor.ButtonBorder, Enum.StudioStyleGuideModifier.Hover)
        ThemeManager.ColorSync(self.ButtonBackground, "ImageColor3", Enum.StudioStyleGuideColor.Button, Enum.StudioStyleGuideModifier.Hover)
    end)
    self.Button.MouseLeave:Connect(function()
        task.wait(0)
        GV.PluginObject:GetMouse().Icon = "rbxasset://SystemCursors/Arrow"
        if self.Disabled or self.Toggleable then return end
        if Pressed and self.ReleasedAction then self.ReleasedAction() end
        Pressed = false
        ThemeManager.ColorSync(self.Button, "ImageColor3", Enum.StudioStyleGuideColor.ButtonBorder)
        ThemeManager.ColorSync(self.ButtonBackground, "ImageColor3", Enum.StudioStyleGuideColor.Button)
    end)

    self.Button.MouseButton1Down:Connect(function()
        if self.Disabled or self.Toggleable then return end
        if self.PressedAction then self.PressedAction() end
        Pressed = true
        ThemeManager.ColorSync(self.Button, "ImageColor3", Enum.StudioStyleGuideColor.ButtonBorder, Enum.StudioStyleGuideModifier.Pressed)
        ThemeManager.ColorSync(self.ButtonBackground, "ImageColor3", Enum.StudioStyleGuideColor.Button, Enum.StudioStyleGuideModifier.Pressed)
    end)

    self.Button.MouseButton1Up:Connect(function()
        if self.Disabled or self.Toggleable then return end
        if self.ReleasedAction then self.ReleasedAction() end
        Pressed = false
        ThemeManager.ColorSync(self.Button, "ImageColor3", Enum.StudioStyleGuideColor.ButtonBorder)
        ThemeManager.ColorSync(self.ButtonBackground, "ImageColor3", Enum.StudioStyleGuideColor.Button)
    end)

    self.Button.MouseButton1Click:Connect(function()
        if not self.Disabled then
            if self.Action then self.Action(self.Value) end
        end
    end)

    self:SetDisabled(self.Arguments.Disabled)
    self.Object = self.Button
    self.MainMovable = self.ButtonFrame
    return self
end

return Button]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2BE30D44BE644EF2A32D7BD54A6C3921">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Checkbox</string>
								<string name="ScriptGuid">{93d2baff-e444-b7e7-f50d-ac0e37caa2db}</string>
								<ProtectedString name="Source"><![CDATA[local Checkbox = {}
Checkbox.__index = Checkbox

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local GUIObject = require(GV.ObjectsDir.GUIObject)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
setmetatable(Checkbox,GUIObject)

Checkbox.Images = {
    check = "http://www.roblox.com/asset/?id=10278675078"
}

function Checkbox:SetDisabled(State)
    self.Disabled = State
    if self.Disabled then
        self.CursorIcon = "rbxasset://SystemCursors/Forbidden"
        self.Checkbox.Transparency, self.CheckImage.ImageTransparency = 0.5, 0.5
    else
        self.CursorIcon = "rbxasset://SystemCursors/PointingHand"
        self.Checkbox.Transparency, self.CheckImage.ImageTransparency = 0, 0
    end
end

function Checkbox:ToggleDisable()
    self:SetDisabled(not self.Disabled)
end

function Checkbox:Toggle()
    self:SetValue(not self.Value)
    return self.Value
end

function Checkbox:SetValue(Toggle)
    self.Value = Toggle
    self.CheckImage.Visible = Toggle
    if Toggle then
        ThemeManager.ColorSync(self.Checkbox, "BackgroundColor3", Enum.StudioStyleGuideColor.CheckedFieldBackground, Enum.StudioStyleGuideModifier.Selected, true, "Light")
    else
        ThemeManager.ColorSync(self.Checkbox, "BackgroundColor3", Enum.StudioStyleGuideColor.CheckedFieldBackground)
    end
end

function Checkbox:Clicked(func)
    self.Action = func
end
-- Value, Disabled
function Checkbox.new(Arguments, Parent)
    local self = GUIObject.new(Arguments, Parent)
    setmetatable(self,Checkbox)
    self.Value = self.Arguments.Value
    self.Disabled = self.Arguments.Disabled
    self.CheckboxFrame = Instance.new("Frame", self.Parent)
    self.CheckboxFrame.BackgroundTransparency = 1
    self.CheckboxFrame.Name = "CheckboxFrame"
    self.Checkbox = Instance.new("TextButton", self.CheckboxFrame)
    self.Checkbox.BackgroundTransparency = 1
    self.Checkbox.AnchorPoint = Vector2.new(0.5,0.5)
    self.Checkbox.Position = UDim2.new(0.5,0,0.5,0)
    self.Checkbox.Size = UDim2.new(0,16,0,16)
    self.Checkbox.Name = "Checkbox"
    self.Checkbox.Text = ""
    ThemeManager.ColorSync(self.Checkbox, "BorderColor3", Enum.StudioStyleGuideColor.CheckedFieldBorder)
    ThemeManager.ColorSync(self.Checkbox, "BackgroundColor3", Enum.StudioStyleGuideColor.CheckedFieldBackground)
    self.CheckImage = Instance.new("ImageLabel", self.Checkbox)
    self.CheckImage.AnchorPoint = Vector2.new(0.5,0.5)
    self.CheckImage.Position = UDim2.new(0.5,0,0.5,0)
    self.CheckImage.Size = UDim2.new(0,16,0,16)
    self.CheckImage.Image = self.Images.check
    self.CheckImage.BackgroundTransparency = 1
    self.CheckImage.Name = "CheckIndicator"
    ThemeManager.ColorSync(self.CheckImage, "ImageColor3", Enum.StudioStyleGuideColor.CheckedFieldIndicator, nil, true, "Dark")
    self.Checkbox.MouseMoved:Connect(function()
        GV.PluginObject:GetMouse().Icon = self.CursorIcon
        if not self.Disabled then
            ThemeManager.ColorSync(self.Checkbox, "BorderColor3", Enum.StudioStyleGuideColor.CheckedFieldBorder, Enum.StudioStyleGuideModifier.Hover)
        end
    end)
    self.Checkbox.MouseLeave:Connect(function()
        task.wait(0)
        GV.PluginObject:GetMouse().Icon = "rbxasset://SystemCursors/Arrow"
        ThemeManager.ColorSync(self.Checkbox, "BorderColor3", Enum.StudioStyleGuideColor.CheckedFieldBorder)
    end)
    self.Checkbox.MouseButton1Click:Connect(function()
        if not self.Disabled then
            self:Toggle()
            if self.Action then self.Action(self.Value) end
        end
    end)
    self:SetValue(self.Value)
    self:SetDisabled(self.Disabled)
    self.Object = self.Checkbox
    self.MainMovable = self.CheckboxFrame
    return self
end

return Checkbox]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF6CB4A9D4D2F4D608FB435906DFF2321">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ColorInput</string>
								<string name="ScriptGuid">{f964d251-4153-1617-3c5e-47a0e1668d30}</string>
								<ProtectedString name="Source"><![CDATA[local ColorInput = {}
ColorInput.__index = ColorInput

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local GUIObject = require(GV.ObjectsDir.GUIObject)
local InputField = require(GV.ObjectsDir.InputField)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
local ColorPrompt = require(GV.PromptsDir.ColorPrompt)
setmetatable(ColorInput,GUIObject)

local RightClickMenu = GV.PluginObject:CreatePluginMenu(game:GetService("HttpService"):GenerateGUID(false), "RightClickMenu - ColorInput")
RightClickMenu.Name = "ColorInput Right-Click Menu"
RightClickMenu:AddNewAction("Reset", "Reset")

function ColorInput:SetDisabled(State)
    self.Disabled = State
    self.ColorInput:SetDisabled(State)
    if self.Disabled then
        self.CursorIcon = "rbxasset://SystemCursors/Forbidden"
        self.ColorButton.BackgroundTransparency = 0.5
    else
        self.CursorIcon = "rbxasset://SystemCursors/PointingHand"
        self.ColorButton.BackgroundTransparency = 0
    end
end

function ColorInput:ToggleDisable()
    self:SetDisabled(not self.Disabled)
end

function ColorInput:SetValue(Value, IgnoreText)
    self.Value = Value
    self.ColorButton.BackgroundColor3 = self.Value
    if not IgnoreText then self.ColorInput.Input.Text = util.Color3ToText(self.Value) end
    if self.Action then self.Action(self.Value) end
end

function ColorInput:Changed(func)
    self.Action = func
end

-- Color/Value/DefaultColor, NoPause, Disabled
function ColorInput.new(Arguments, Parent)
    local self = GUIObject.new(Arguments, Parent)
    setmetatable(self,ColorInput)
    self.IgnoreText = true
    self.Disabled = self.Arguments.Disabled
    self.ColorInputContainer = Instance.new("Frame", self.Parent)
    self.ColorInputContainer.BackgroundTransparency = 1
    self.ColorInputContainer.Name = "ColorInputContainer"
    self.ColorInputFrame = Instance.new("Frame", self.ColorInputContainer)
    self.ColorInputFrame.Name = "ColorInputFrame"
    self.ColorInputFrame.AnchorPoint = Vector2.new(0.5,0.5)
    self.ColorInputFrame.BackgroundTransparency = 1
    self.ColorInputFrame.Position = UDim2.new(0.5,0,0.5,0)
    self.ColorInputFrame.Size = UDim2.new(0,130,1,0)
    self.ColorInputLayout = Instance.new("UIListLayout", self.ColorInputFrame)
    self.ColorInputLayout.Padding = UDim.new(0,10)
    self.ColorInputLayout.FillDirection = Enum.FillDirection.Horizontal
    self.ColorInputLayout.SortOrder = Enum.SortOrder.LayoutOrder
    self.ColorInputLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    self.ColorButton = Instance.new("TextButton", self.ColorInputFrame)
    self.ColorButton.Name = "ColorButton"
    self.ColorButton.Size = UDim2.new(0,18,0,18)
    ThemeManager.ColorSync(self.ColorButton, "BorderColor3", Enum.StudioStyleGuideColor.InputFieldBorder)
    self.ColorButton.Text = ""
    self.ColorButton.MouseButton1Click:Connect(function()
        if self.Disabled then return end
        local prompt = ColorPrompt.new({Value = self.Value, NoPause = self.Arguments.NoPause})
        prompt:Done(function(p)
            self:SetValue(p)
        end)
        prompt:Changed(function(p)
            self:SetValue(p)
        end)
    end)
    self.ColorButton.MouseButton2Click:Connect(function()
        if self.Disabled then return end
        local Response = RightClickMenu:ShowAsync()
        if Response then 
            if Response.Text == "Reset" then self:SetValue(self.DefaultValue) end
        end
    end)
    self.ColorInput = InputField.new({NoDropdown = true, ClearBackground = true}, self.ColorInputFrame)
    self.ColorInput.Name = "ColorInput"
    self.ColorInput.InputFieldContainer.Size = UDim2.new(0,100,0,20)
    self.ColorInput.InputFieldFrame.Size = UDim2.new(1,0,1,0)
    self.ColorInput.Input.TextXAlignment = Enum.TextXAlignment.Center
    self.ColorInput:Changed(function(p)
        self:SetValue(util.TextToColor3(p), true)
    end)
    self.ColorInput:LostFocus(function(p)
        self:SetValue(util.TextToColor3(p))
        self.ColorInput.Input.TextXAlignment = Enum.TextXAlignment.Center
    end)
    self.ColorInput:GainedFocus(function()
        self.ColorInput.Input.TextXAlignment = Enum.TextXAlignment.Left
    end)
    self.ColorButton.MouseMoved:Connect(function()
        GV.PluginObject:GetMouse().Icon = self.CursorIcon
    end)
    self.ColorButton.MouseLeave:Connect(function()
        task.wait(0)
        GV.PluginObject:GetMouse().Icon = "rbxasset://SystemCursors/Arrow"
    end)
    self.DefaultValue = self.Arguments.Color or self.Arguments.Value or Color3.new(1,1,1)
    self:SetValue(self.DefaultValue)
    self:SetDisabled(self.Disabled)
    self.Object = self.ColorButton
    self.MainMovable = self.ColorInputContainer
    return self
end

return ColorInput]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3C8CEBBDD38944D78D13A96077057070">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">GUIObject</string>
								<string name="ScriptGuid">{c5f8fea9-4026-e7b7-c550-943eb94796b0}</string>
								<ProtectedString name="Source"><![CDATA[local GUIObject = {}
GUIObject.__index = GUIObject
local GV = require(script.Parent.Parent.PluginGlobalVariables)
local GUIElement = require(GV.LibraryDir.GUIElement)
local ListFrame = require(GV.FramesDir.ListFrame)
setmetatable(GUIObject,GUIElement)
GV.ObjectList = {}

function GUIObject.new(Arguments, Parent)
    local self = GUIElement.new(Arguments, Parent or ListFrame.new().Content)
    setmetatable(self,GUIObject)
    self.Object = nil
    self.MainMovable = nil
    GV.ObjectList[#GV.ObjectList+1] = self
    return self
end

function GUIObject:Move(NewFrame, WithFrame)
    local PreviousParent = self.Parent
    self.MainMovable.Parent = NewFrame
    self.Parent = NewFrame
    if PreviousParent:IsA("Frame") and WithFrame then
        for _, i in pairs(PreviousParent:GetChildren()) do
            if i:IsA("Frame") then
                return self.Object
            end
        end
        PreviousParent:Destroy()
    end
end



return GUIObject]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX02D07563E016424AB96AD881EFE0C06B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">InputField</string>
								<string name="ScriptGuid">{24563585-5584-5808-dc2d-7a50136b2a90}</string>
								<ProtectedString name="Source"><![CDATA[local InputField = {}
InputField.__index = InputField

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local GUIObject = require(GV.ObjectsDir.GUIObject)
local ScrollingFrame = require(GV.FramesDir.ScrollingFrame)
local KeybindManager = require(GV.ManagersDir.KeybindManager)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
local InputManager = require(GV.ManagersDir.InputManager)
setmetatable(InputField,GUIObject)

local RightClickMenu = GV.PluginObject:CreatePluginMenu(game:GetService("HttpService"):GenerateGUID(false), "RightClickMenu - InputField")
RightClickMenu.Name = "InputField Right-Click Menu"
RightClickMenu:AddNewAction("Edit", "Edit")
RightClickMenu:AddNewAction("Clear", "Clear Input")


InputField.Images = {
    Down = "http://www.roblox.com/asset/?id=10027472547"
}

function InputField:SetDisabled(State)
    self.Disabled = State
    if self.Disabled then
        if self.DropdownOpen then self:SetDropdown(false) end
        self.InputFieldFrame.BackgroundTransparency, self.Input.TextTransparency, self.DropdownButton.BackgroundTransparency = 0.5,0.5,0.5
    else
        self.InputFieldFrame.BackgroundTransparency, self.Input.TextTransparency, self.DropdownButton.BackgroundTransparency = 0,0,0
    end
    if self.TextboxEditable then
        self.Input.TextEditable = not State
    end
end

function InputField:ToggleDisable()
    self:SetDisabled(not self.Disabled)
end

function InputField:ToggleDropdown()
    self:SetDropdown(not self.DropdownOpen)
end

function InputField:SetDropdown(State)
    self.DropdownOpen = State
    self.DropdownFrame.Visible = State
    if State then
        self.Parent.ZIndex = 2
        self.InputFieldFrame.ZIndex = 3
        self.DropdownButton.ZIndex = 3
        self.DropdownImage.ZIndex = 3
        self.Input.ZIndex = 4
        
    else
        self.Parent.ZIndex = 0
        self.InputFieldFrame.ZIndex = 0
        self.DropdownImage.ZIndex = 0
        self.DropdownButton.ZIndex = 0
        self.Input.ZIndex = 0
        
    end
    if self.DropdownAction then self.DropdownAction(State) end
end

function InputField.GenerateInstanceList(Instances)
    if typeof(Instances) == "Instance" then Instances = {Instances} end
    local GeneratedList = Instances[1].Name
    for i, v in pairs(Instances) do
        if i ~= 1 then
            GeneratedList = GeneratedList .. ", " .. v.Name
        end
    end
    return GeneratedList
end

function InputField.GetItemInfo(Item)
    local ItemInfo = Item or ""
    if not (typeof(ItemInfo) == "table") then ItemInfo = {Value = Item, Name = Item} end
    if (not ItemInfo.Value) and (not ItemInfo.Name) then ItemInfo = {Value = ItemInfo} end
    ItemInfo.Value = ItemInfo.Value or ItemInfo.Name
    ItemInfo.Name = ItemInfo.Name or ItemInfo.Value
    if typeof(ItemInfo.Name) ~= "string" and typeof(ItemInfo.Name) ~= "number" then
        if typeof(ItemInfo.Value) == "table" then
            if #ItemInfo.Value < 1 then return {Value = "", Name = ""} end
            if typeof(ItemInfo.Value[1]) == "Instance" then
                ItemInfo.Name = InputField.GenerateInstanceList(ItemInfo.Value)
            else
                ItemInfo.Name = nil
            end
        elseif typeof(ItemInfo.Value) == "Instance" then
            ItemInfo.Name = ItemInfo.Value.Name
            ItemInfo.Value = {ItemInfo.Value}
        elseif typeof(ItemInfo.Value) == "EnumItem" then
            ItemInfo.Name = ItemInfo.Value.Name
        else
            ItemInfo.Name = tostring(ItemInfo.Value)
        end
    end
    return ItemInfo
end

function InputField:AddItem(Item, Action)
    local ItemInfo = self.GetItemInfo(Item)
    local ItemButton = Instance.new("TextButton", self.DropdownScroll.Content)
    ItemButton.Name = ItemInfo.Name
    ItemButton.Size = UDim2.new(1,0,0,20)
    ItemButton.BorderSizePixel = 0
    ThemeManager.ColorSync(ItemButton, "BackgroundColor3", Enum.StudioStyleGuideColor.InputFieldBackground)
    ItemButton.Text = ""
    local ItemLabel = Instance.new("TextLabel", ItemButton)
    ItemLabel.BackgroundTransparency = 1
    ThemeManager.ColorSync(ItemLabel, "TextColor3", Enum.StudioStyleGuideColor.MainText)
    ItemLabel.Font = Enum.Font.SourceSans
    ItemLabel.TextSize = 14
    ItemLabel.Text = ItemInfo.Name
    ItemLabel.AnchorPoint = Vector2.new(0.5,0.5)
    ItemLabel.Position = UDim2.new(0.5,0,0.5,0)
    ItemLabel.Size = UDim2.new(1,-8,0,14)
    ItemButton.ZIndex = 2
    ItemLabel.ZIndex = 2
    ItemLabel.TextXAlignment = Enum.TextXAlignment.Left
    util.HoverIcon(ItemButton)
    self.DropdownButton.MouseButton1Click:Connect(function() if not self.Disabled then ItemButton.Visible = true end end)
    self.Input.Changed:Connect(function(p)
        if p == "Text" and self.Filtering then
            if self.Input.Text == "" or string.sub(ItemInfo.Name, 1, string.len(self.Input.Text)) == self.Input.Text then
                ItemButton.Visible = true
            else
                ItemButton.Visible = false
            end
        end
    end)
    ItemButton.MouseButton1Click:Connect(function()
        if self.Disabled then return end
        self:SetDropdown(false)
        self.SelectedItem = true
        self.Value = ItemInfo.Value
        self.Input.Text = ItemInfo.Name
        if Action then
            Action()
        end
    end)
    ItemButton.MouseEnter:Connect(function()
        task.wait(0)
        if self.Disabled then return end
        if self.ItemEnterAction then self.ItemEnterAction(ItemInfo.Value) end
    end)
    ItemButton.MouseLeave:Connect(function()
        if self.Disabled then return end
        if self.ItemLeaveAction then self.ItemLeaveAction(ItemInfo.Value) end
    end)
end

function InputField:AddItems(Items, Action)
    for _, v in pairs(Items) do self:AddItem(v, Action) end
end

function InputField:ClearItems()
    for _, v in pairs(self.DropdownScroll.Content:GetChildren()) do
        if v:IsA("TextButton") then v:Destroy() end
    end
end

function InputField:RemoveItem(Item)
    local Target = self.DropdownScroll.Content:FindFirstChild(Item)
    if Target then
        Target:Destroy()
    end
end

function InputField:RemoveItems(Items)
    for _, v in pairs(Items) do self:RemoveItem(v) end
end

function InputField:SetValue(Item)
    local ItemInfo = self.GetItemInfo(Item)
    if self.Value == ItemInfo.Value then return end
    self.SelectedItem = true
    self.Value = ItemInfo.Value
    self.Input.Text = ItemInfo.Name or ""
end

function InputField:Changed(func)
    self.Action = func
end

function InputField:MouseEnterItem(func)
    self.ItemEnterAction = func
end

function InputField:MouseLeaveItem(func)
    self.ItemLeaveAction = func
end

function InputField:DropdownToggled(func)
    self.DropdownAction = func
end

function InputField:LostFocus(func)
    self.LostFocusAction = func
end

function InputField:GainedFocus(func)
    self.FocusedAction = func
end

-- Placeholder, Value, Items, InputSize, NoDropdown, NoFiltering, DisableEditing, ClearBackground, ClearText, Disabled
function InputField.new(Arguments, Parent)
    local self = GUIObject.new(Arguments, Parent)
    setmetatable(self,InputField)
    self.DefaultEmpty = ""
    self.Action = nil
    self.Filtering = not self.Arguments.NoFiltering
    self.InputFieldContainer = Instance.new("Frame", self.Parent)
    self.InputFieldContainer.BackgroundTransparency = 1
    self.InputFieldContainer.Name = "InputFieldContainer"
    self.InputFieldFrame = Instance.new("Frame", self.InputFieldContainer)
    self.InputFieldFrame.BackgroundTransparency = 1
    local Size = util.GetScale(self.Arguments.InputSize) or UDim.new(1,-12)
    self.InputFieldFrame.Size = UDim2.new(Size.Scale,Size.Offset,0,20)
    self.InputFieldFrame.Position = UDim2.new(0.5,0,0.5,0)
    self.InputFieldFrame.AnchorPoint = Vector2.new(0.5,0.5)
    self.InputFieldFrame.Name = "InputFieldFrame"
    if self.Arguments.ClearBackground then
        ThemeManager.ColorSync(self.InputFieldFrame, "BorderColor3", Enum.StudioStyleGuideColor.MainBackground)
        ThemeManager.ColorSync(self.InputFieldFrame, "BackgroundColor3", Enum.StudioStyleGuideColor.MainBackground)
    else
        ThemeManager.ColorSync(self.InputFieldFrame, "BorderColor3", Enum.StudioStyleGuideColor.InputFieldBorder)
        ThemeManager.ColorSync(self.InputFieldFrame, "BackgroundColor3", Enum.StudioStyleGuideColor.InputFieldBackground)
    end
    self.Input = Instance.new("TextBox", self.InputFieldFrame)
    self.Input.TextTruncate = Enum.TextTruncate.AtEnd
    self.Input.BackgroundTransparency = 1
    if self.Arguments.NoDropdown then self.Input.Size = UDim2.new(1,-10,1,0) else self.Input.Size = UDim2.new(1,-30,1,0) end
    self.Input.Font = Enum.Font.SourceSans
    self.Input.TextSize = 14
    if self.Arguments.Placeholder then self.Input.PlaceholderText = self.Arguments.Placeholder end
    self.Input.TextXAlignment = Enum.TextXAlignment.Left
    self.Input.Position = UDim2.new(0,5,0,0)
    self.Input.ClearTextOnFocus = self.Arguments.ClearText
    self.Input.Name = "Input"
    self.Input.Changed:Connect(function(p)
        if p == "Text" then
            if not self.SelectedItem and not self.IgnoreText then
                self.Value = self.Input.Text
            end
            self.SelectedItem = false
            if self.Value == "" then self.Value = self.DefaultEmpty end
            if self.Action then
                self.Action(self.Value)
            end
        end
    end)
    self.Focusable = true
    self.TextEditable = true
    if self.Arguments.DisableEditing then
        self.Input.TextEditable = false
        self.TextboxEditable = false
        self.Focusable = false
        self.TextEditable = false
    end
    ThemeManager.ColorSync(self.Input, "TextColor3", Enum.StudioStyleGuideColor.MainText)
    ThemeManager.ColorSync(self.Input, "PlaceholderColor3", Enum.StudioStyleGuideColor.DimmedText)
    self.MouseInInput = false
    self.InputFieldFrame.MouseMoved:Connect(function()
        self.MouseInInput = true
        if not self.Disabled and not self.Input:IsFocused() and not self.Focused then
            ThemeManager.ColorSync(self.InputFieldFrame, "BorderColor3", Enum.StudioStyleGuideColor.InputFieldBorder, Enum.StudioStyleGuideModifier.Hover)
            if self.Arguments.ClearBackground then
                ThemeManager.ColorSync(self.InputFieldFrame, "BackgroundColor3", Enum.StudioStyleGuideColor.InputFieldBorder, Enum.StudioStyleGuideModifier.Hover)
            end
        elseif self.Focusable then
            GV.PluginObject:GetMouse().Icon = "rbxasset://SystemCursors/Forbidden"
        end
    end)
    self.InputFieldFrame.MouseLeave:Connect(function()
        self.MouseInInput = false
        if not self.Disabled and not self.Input:IsFocused() and not self.Focused then
            if self.Arguments.ClearBackground then
                ThemeManager.ColorSync(self.InputFieldFrame, "BorderColor3", Enum.StudioStyleGuideColor.MainBackground)
                ThemeManager.ColorSync(self.InputFieldFrame, "BackgroundColor3", Enum.StudioStyleGuideColor.MainBackground)
            else
                ThemeManager.ColorSync(self.InputFieldFrame, "BorderColor3", Enum.StudioStyleGuideColor.InputFieldBorder)
            end
        end
        GV.PluginObject:GetMouse().Icon = "rbxasset://SystemCursors/Arrow"
    end)
    self.Input.Focused:Connect(function()
        KeybindManager.Unfocus()
        if not self.Disabled and self.Focusable then
            if self.FocusedAction then self.FocusedAction(self.Value) end
            ThemeManager.ColorSync(self.InputFieldFrame, "BorderColor3", Enum.StudioStyleGuideColor.InputFieldBorder, Enum.StudioStyleGuideModifier.Selected, true)
            ThemeManager.ColorSync(self.InputFieldFrame, "BackgroundColor3", Enum.StudioStyleGuideColor.InputFieldBackground)
        else
            self.Input:ReleaseFocus()
        end
    end)
    self.Input.FocusLost:Connect(function()
        if self.Focusable then
            if self.LostFocusAction then self.LostFocusAction(self.Value) end
            if self.Arguments.ClearBackground then
                ThemeManager.ColorSync(self.InputFieldFrame, "BorderColor3", Enum.StudioStyleGuideColor.MainBackground)
                ThemeManager.ColorSync(self.InputFieldFrame, "BackgroundColor3", Enum.StudioStyleGuideColor.MainBackground)
            else
                ThemeManager.ColorSync(self.InputFieldFrame, "BorderColor3", Enum.StudioStyleGuideColor.InputFieldBorder)
                ThemeManager.ColorSync(self.InputFieldFrame, "BackgroundColor3", Enum.StudioStyleGuideColor.InputFieldBackground)
            end
        end
    end)
    self.DropdownButton = Instance.new("TextButton", self.InputFieldFrame)
    if self.Arguments.NoDropdown then self.DropdownButton.Visible = false end
    self.DropdownButton.Text = ""
    ThemeManager.ColorSync(self.DropdownButton, "BackgroundColor3", Enum.StudioStyleGuideColor.InputFieldBackground)
    self.DropdownButton.BorderSizePixel = 0
    self.DropdownButton.Size = UDim2.new(0, 20, 0, 20)
    self.DropdownButton.AnchorPoint = Vector2.new(1,0)
    self.DropdownButton.Position = UDim2.new(1, 0, 0, 0)
    self.DropdownButton.Name = "DropdownButton"
    util.HoverIcon(self.DropdownButton)
    self.DropdownButton.MouseButton1Click:Connect(function() if not self.Disabled then self:ToggleDropdown() end end)
    self.MouseInDropdownButton = false
    self.DropdownButton.MouseEnter:Connect(function() self.MouseInDropdownButton = true end)
    self.DropdownButton.MouseLeave:Connect(function() self.MouseInDropdownButton = false end)
    self.DropdownImage = Instance.new("ImageLabel", self.DropdownButton)
    self.DropdownImage.Name = "Dropdown Image"
    self.DropdownImage.AnchorPoint = Vector2.new(0.5,0.5)
    self.DropdownImage.BackgroundTransparency = 1
    self.DropdownImage.Position = UDim2.new(0.5,0,0.5,0)
    self.DropdownImage.Size = UDim2.new(0,4.5,0,4.5)
    self.DropdownImage.Image = self.Images.Down
    self.DropdownFrame = Instance.new("Frame", self.InputFieldFrame)
    self.DropdownFrame.Size = UDim2.new(1,0,0,0)
    self.DropdownFrame.Position = UDim2.new(0,0,1,0)
    ThemeManager.ColorSync(self.DropdownFrame, "BackgroundColor3", Enum.StudioStyleGuideColor.InputFieldBackground)
    ThemeManager.ColorSync(self.DropdownFrame, "BorderColor3", Enum.StudioStyleGuideColor.InputFieldBorder)
    self.DropdownFrame.Visible = false
    self.DropdownFrame.Name = "DropdownFrame"
    self.MouseInDropdownMenu = false
    self.DropdownFrame.MouseEnter:Connect(function() self.MouseInDropdownMenu = true end)
    self.DropdownFrame.MouseLeave:Connect(function() self.MouseInDropdownMenu = false end)
    self.DropdownFrame.ZIndex = 2
    self.DropdownScroll = ScrollingFrame.new({BarSize = 10}, self.DropdownFrame)
    self:SetDropdown(false)
    self.DropdownMaxY = 100
    local function syncframe()
        if self.DropdownScroll.Layout.AbsoluteContentSize.Y > self.DropdownMaxY then
            self.DropdownFrame.Size = UDim2.new(1,0,0,self.DropdownMaxY)
            return
        end
        self.DropdownFrame.Size = UDim2.new(1,0,0,self.DropdownScroll.Layout.AbsoluteContentSize.Y)
    end
    self.DropdownScroll.Layout.Changed:Connect(function(p)
        if p == "AbsoluteContentSize" then syncframe() end
    end)
    syncframe()
    InputManager.AddInputEvent("InputBegan", function(p)
        task.wait(0)
        if self.DropdownOpen and p.UserInputType == Enum.UserInputType.MouseButton1 and not self.MouseInDropdownMenu and not self.MouseInDropdownButton then
            self:SetDropdown(false)
        end
        if self.TextEditable and p.UserInputType == Enum.UserInputType.MouseButton2 and self.MouseInInput then
            local Response = RightClickMenu:ShowAsync()
            if Response then 
                if Response.Text == "Clear Input" then self.Input.Text = ""
                elseif Response.Text == "Edit" then self.Input:CaptureFocus() end
            end
        end
    end)
    local Value = self.Arguments.Value or self.Arguments.CurrentItem or ""
    self:SetValue(Value)
    if self.Arguments.Items then self:AddItems(self.Arguments.Items) end
    self:SetDisabled(self.Arguments.Disabled)
    self.Object = self.Input
    self.MainMovable = self.InputFieldContainer
    return self
end

return InputField]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXEBA942A324C6474AA9B6E5B70E11F8A3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">InstanceInputField</string>
								<string name="ScriptGuid">{eca54955-8ba8-cb2f-ac25-afad6689a8ab}</string>
								<ProtectedString name="Source"><![CDATA[local InstanceInputField = {}
InstanceInputField.__index = InstanceInputField

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local InputField = require(GV.ObjectsDir.InputField)
local Selection = game:GetService("Selection")
setmetatable(InstanceInputField,InputField)

function InstanceInputField.new(Arguments, Parent)
    Arguments = Arguments or {}
    Arguments.Placeholder = Arguments.Placeholder or "Select object(s)"
    Arguments.DisableEditing = true
    local self = InputField.new(Arguments, Parent)
    setmetatable(self,InstanceInputField)
    self.IgnoreText = true
    self.DefaultEmpty = {}
    self.Focusable = true
    self.TextEditable = true
    self.Input.Focused:Connect(function()
        if self.Disabled then return end
        local CurrentSelection = Selection:Get()
        if #CurrentSelection > 0 then self:SetValue(CurrentSelection) end
    end)
    Selection.SelectionChanged:Connect(function()
        if self.Disabled then return end
        if self.Input:IsFocused() then
            local CurrentSelection = Selection:Get()
            if #CurrentSelection > 0 then self:SetValue(CurrentSelection) end
        end
    end)
    return self
end

return InstanceInputField]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXADCB1626C3984DE98A24D1C0D96606A3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">KeybindInputField</string>
								<string name="ScriptGuid">{80177e99-f5d5-2caf-7cc1-73bca1bc5329}</string>
								<ProtectedString name="Source"><![CDATA[local KeybindInputField = {}
KeybindInputField.__index = KeybindInputField

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local KeybindManager = require(GV.ManagersDir.KeybindManager)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
local InputField = require(GV.ObjectsDir.InputField)
local KeybindNum = 0
setmetatable(KeybindInputField,InputField)

--[[
    How to make keybinds in code
    Always use Left if its control alt or shift
    ex:
    {{LeftControl, LeftAlt, Zero},{P}}
    {{"Keybind Preset",{{LeftControl, LeftAlt, Zero},{P}}}}
]]--

function KeybindInputField:UpdateValues(Value)
    Value = Value or self.Value
    KeybindManager.UpdateKeybinds(self.ID, {Keybinds = Value, Holdable = self.Holdable, PressedAction = self.PressedAction, ReleasedAction = self.ReleasedAction})
end

function KeybindInputField:UpdateBind(Value)
    if not Value then return end
    if #Value[1]>0 and #Value[#Value]>0 then Value[#Value + 1] = {} end
    self:UpdateValues(Value)
end

function KeybindInputField:SetBind(Bind)
    Bind = Bind or {Value = {{}}}
    local BindInfo = self.GetItemInfo(Bind)
    local Value = BindInfo.Value
    self:UpdateBind(Value)
    self:SetValue({Name = BindInfo.Name or KeybindManager.GenerateKeybindList(Value), ["Value"] = Value})
end

function KeybindInputField:AddBind(Bind)
    local BindInfo = self.GetItemInfo(Bind)
    if #BindInfo.Value[1]>0 and #BindInfo.Value[#BindInfo.Value]>0 then BindInfo.Value[#BindInfo.Value+1] = {} end
    self:AddItem({Name = BindInfo.Name or KeybindManager.GenerateKeybindList(BindInfo.Value), Value = BindInfo.Value}, function() self:UpdateBind(BindInfo.Value) end)
end

function KeybindInputField:AddBinds(Binds)
    for _, Bind in pairs(Binds) do
        self:AddBind(Bind)
    end
end

function KeybindInputField:EditKeybind(Keybind, Complete)
    local Value = util.CopyTable(self.Value)
    Value[#Value] = Keybind
    if Complete then
        Value[#Value+1] = {}
    end
    self:UpdateValues(Value)
    self:SetValue({Name = KeybindManager.GenerateKeybindList(Value), ["Value"] = Value})
end

function KeybindInputField:RemoveKeybind(Index)
    local Value = util.CopyTable(self.Value)
    Index = Index or #Value - 1
    table.remove(Value, Index)
    self:SetValue({Name = KeybindManager.GenerateKeybindList(Value), ["Value"] = Value})
end

function KeybindInputField:UnfocusInputField(ForceUnfocus)
    if not ForceUnfocus and self.MouseInInput then return false
    else
        ThemeManager.ColorSync(self.InputFieldFrame, "BorderColor3", Enum.StudioStyleGuideColor.InputFieldBorder)
        self.Focused = false
    end
    return true
end

function KeybindInputField:Pressed(func)
    function self.PressedAction()
        if not self.Disabled and func then func() end
    end
    self:UpdateValues()
end

function KeybindInputField:Released(func)
    function self.ReleasedAction()
        if not self.Disabled and func then func() end
    end
    self:UpdateValues()
end

-- PressedAction, ReleasedAction, Holdable, Unrestricted, Bind/CurrentBind, Items/Binds
function KeybindInputField.new(Arguments, Parent)
    Arguments = Arguments or {}
    KeybindNum += 1
    Arguments.Placeholder = Arguments.Placeholder or "Set Keybind"
    Arguments.DisableEditing = true
    local self = InputField.new(Arguments, Parent)
    setmetatable(self,KeybindInputField)
    self.IgnoreText = true
    self.Holdable = self.Arguments.Holdable
    self.Unrestricted = self.Arguments.Unrestricted
    if not self.Holdable then self.Holdable = false end
    if not self.Unrestricted then self.Unrestricted = false end
    self.DefaultEmpty = {{}}
    self.TextEditable = true
    self.ID = KeybindNum
    self:Pressed(self.Arguments.PressedAction)
    self:Released(self.Arguments.ReleasedAction)
    self.Value = {{}}
    self.Arguments.Binds = self.Arguments.Items or self.Arguments.Binds
    self.Input.Focused:Connect(function()
        if self.Disabled then return end
        self.Focused = true
        ThemeManager.ColorSync(self.InputFieldFrame, "BorderColor3", Enum.StudioStyleGuideColor.InputFieldBorder, Enum.StudioStyleGuideModifier.Selected, true)
        task.wait()
        KeybindManager.FocusInputField(self.ID, self, self.EditKeybind, self.RemoveKeybind, self.UnfocusInputField)
    end)
    if self.Arguments.Binds then self:AddBinds(self.Arguments.Binds) end
    self:SetBind(self.Arguments.Bind or self.Arguments.CurrentBind)
    return self
end

return KeybindInputField]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX23060D8613C14517B805AA1D4323C825">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Labeled</string>
								<string name="ScriptGuid">{255bfff9-ace4-6c80-f9a5-578c646c087a}</string>
								<ProtectedString name="Source"><![CDATA[local LabeledObject = {}
LabeledObject.__index = LabeledObject

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local TextboxMod = require(GV.ObjectsDir.Textbox)
local GUIObject = require(GV.ObjectsDir.GUIObject)
setmetatable(LabeledObject,GUIObject)

function LabeledObject:SetDisabled(State)
    self.Disabled = State
    for _, v in pairs(self.Objects) do v:SetDisabled(State) end
    if self.Disabled then
        self.Label.TextTransparency = 0.5
    else
        self.Label.TextTransparency = 0
    end
end

function LabeledObject:ToggleDisable()
    self:SetDisabled(not self.Disabled)
end

function LabeledObject:AddObject(Object, Name, Size)
    Object:Move(self.Content, true)
    Size = util.GetScale(Size)
    if not Size then Size = UDim.new(1-self.TotalUsedScale, -self.TotalUsedOffset) end
    Object.MainMovable.Size = UDim2.new(Size.Scale,Size.Offset,1,0)
    Object.MainMovable.Position = UDim2.new(self.TotalUsedScale,self.TotalUsedOffset,0,0)
    self.TotalUsedScale += Size.Scale
    self.TotalUsedOffset += Size.Offset
    self[Name] = Object
    self.Objects[#self.Objects+1] = Object
end

-- Textbox, LabelSize, Objects
function LabeledObject.new(Arguments, Parent)
    local self = GUIObject.new(Arguments, Parent)
    setmetatable(self,LabeledObject)
    self.Objects = {}
    self.TotalUsedScale = 0
    self.TotalUsedOffset = 0
    self.MainFrame = Instance.new("Frame", self.Parent)
    self.MainFrame.BackgroundTransparency = 1
    self.MainFrame.Name = "MainFrame"
    self.MainLayout = Instance.new("UIListLayout", self.MainFrame)
    self.MainLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    self.MainLayout.SortOrder = Enum.SortOrder.LayoutOrder
    self.MainLayout.FillDirection = Enum.FillDirection.Horizontal
    self.MainPadding = Instance.new("UIPadding", self.MainFrame)
    self.MainPadding.PaddingBottom, self.MainPadding.PaddingLeft, self.MainPadding.PaddingRight, self.MainPadding.PaddingTop = UDim.new(0,2), UDim.new(0,6), UDim.new(0,0), UDim.new(0,2)
    local Textbox = self.Arguments.Textbox or self.Arguments.Text
    if type(Textbox) == "string" then
        self.TextboxTable = TextboxMod.new({Text = Textbox, Alignment = Enum.TextXAlignment.Left, TextSize = 14}, self.MainFrame)
    else
        self.TextboxTable = Textbox
        Textbox:Move(self.MainFrame, true)
    end
    self.Label = self.TextboxTable.Textbox
    self.Content = Instance.new("Frame", self.MainFrame)
    self.Content.Name = "Content"
    self.Content.BackgroundTransparency = 1
    local LabelSize = util.GetScale(self.Arguments.LabelSize)
    if LabelSize then
        self.Label.Size = UDim2.new(LabelSize.Scale, LabelSize.Offset, 0, 20)
        self.Content.Size = UDim2.new(1-LabelSize.Scale, -LabelSize.Offset, 0, 20)
    else
        local function sync()
            self.Label.Size = UDim2.new(0,self.Label.TextBounds.X+self.Label.TextSize, 1, 0)
            self.Content.Size = UDim2.new(1,-(self.Label.TextBounds.X+self.Label.TextSize), 0, 20)
        end
        self.Label.Changed:Connect(function(p)
            if p == "TextBounds" then sync() end
        end)
    end
    self.TotalUsedScale = 0
    local Objects = self.Arguments.Objects or self.Arguments.Object
    if type(Objects) == "table" and Objects[1] and type(Objects[1] == "table") then
        for _, v in pairs(Objects) do
            self:AddObject(v.Object, v.Name, v.Size)
        end
    else
        self:AddObject(Objects, "Object")
    end
    self:SetDisabled(self.Arguments.Disabled)
    self.MainMovable = self.MainFrame
    return self
end

return LabeledObject]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE84164AF04814042BF52F260EAEAAD47">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ObjectTemplate</string>
								<string name="ScriptGuid">{ef202801-c78b-54de-eaa3-ee017c0b679c}</string>
								<ProtectedString name="Source"><![CDATA[local temp = {}
temp.__index = temp

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local GUIObject = require(GV.ObjectsDir.GUIObject)
setmetatable(temp,GUIObject)

function temp.new(Arguments, Parent)
    local self = GUIObject.new(Arguments, Parent)
    setmetatable(self,temp)
    self.Object = nil
    self.MainMovable = nil
    return self
end

return temp]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4D55FDDD0FD24A519AF907E6998E787A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ProgressBar</string>
								<string name="ScriptGuid">{8127ad3e-25eb-7f45-f785-8a03be918009}</string>
								<ProtectedString name="Source"><![CDATA[local ProgressBar = {}
ProgressBar.__index = ProgressBar

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local GUIObject = require(GV.ObjectsDir.GUIObject)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
setmetatable(ProgressBar,GUIObject)

function ProgressBar:SetDisabled(State)
    self.Disabled = State
    if self.Disabled then
        self.ProgressBar.BackgroundTransparency, self.ProgressIndicator.BackgroundTransparency = 0.5, 0.5
    else
        self.ProgressBar.BackgroundTransparency, self.ProgressIndicator.BackgroundTransparency = 0, 0
    end
end

function ProgressBar:ToggleDisable()
    self:SetDisabled(not self.Disabled)
end

function ProgressBar:SetValue(Value)
    self.Value = Value
    self.ProgressIndicator.Size = UDim2.new(self.Value,0,1,0)
end

-- BarSize, Value, Disabled
function ProgressBar.new(Arguments, Parent)
    local self = GUIObject.new(Arguments, Parent)
    setmetatable(self,ProgressBar)
    self.ProgressBarContainer = Instance.new("Frame", self.Parent)
    self.ProgressBarContainer.Name = "ProgressBarContainer"
    self.ProgressBarContainer.BackgroundTransparency = 1
    self.ProgressBarContainer.Size = UDim2.new(1,0,1,0)
    self.ProgressBar = Instance.new("Frame", self.ProgressBarContainer)
    self.ProgressBar.Name = "ProgressBar"
    self.ProgressBar.AnchorPoint = Vector2.new(0.5,0.5)
    local Size = util.GetScale(self.Arguments.BarSize) or UDim.new(1,-12)
    self.ProgressBar.Size = UDim2.new(Size.Scale,Size.Offset,0,16)
    self.ProgressBar.Position = UDim2.new(0.5,0,0.5,0)
    ThemeManager.ColorSync(self.ProgressBar, "BackgroundColor3", Enum.StudioStyleGuideColor.InputFieldBackground)
    ThemeManager.ColorSync(self.ProgressBar, "BorderColor3", Enum.StudioStyleGuideColor.InputFieldBorder)
    self.ProgressIndicator = Instance.new("Frame", self.ProgressBar)
    self.ProgressIndicator.Name = "Indicator"
    self:SetValue(self.Arguments.Value)
    self.ProgressIndicator.BorderSizePixel = 0
    ThemeManager.ColorSync(self.ProgressIndicator, "BackgroundColor3", Enum.StudioStyleGuideColor.LinkText, nil, true)
    self:SetDisabled(self.Arguments.Disabled)
    self.Object = self.ProgressIndicator
    self.MainMovable = self.ProgressBarContainer
    return self
end

return ProgressBar]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX13734F107DB24E6294E778EFFD97CD7F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Slider</string>
								<string name="ScriptGuid">{ef983ddb-3a93-83ea-c853-30a2958009fe}</string>
								<ProtectedString name="Source"><![CDATA[local Slider = {}
Slider.__index = Slider

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local GUIObject = require(GV.ObjectsDir.GUIObject)
local InputManager = require(GV.ManagersDir.InputManager)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
setmetatable(Slider,GUIObject)

function Slider:SetDisabled(State)
    self.Disabled = State
    self.SliderSelected = false
    if self.Disabled then
        self.CursorIcon = "rbxasset://SystemCursors/Forbidden"
        self.SlideBar.BackgroundTransparency, self.SlideButton.BackgroundTransparency = 0.5, 0.5
    else
        self.CursorIcon = "rbxasset://SystemCursors/PointingHand"
        self.SlideBar.BackgroundTransparency, self.SlideButton.BackgroundTransparency = 0, 0
    end
end

function Slider:SetValue(Value)
    self.Value = Value
    self:UpdatePosition()
end

function Slider:SetRange(Min, Max)
    self.Min = Min
    self.Max = Max
    self:UpdatePosition()
end

function Slider:UpdatePosition()
    self.SlideButton.Position = UDim2.new((self.Value-self.Min)/(self.Max - self.Min), 0, 0.5, 0)
    if self.Value ~= self.PreviousValue then
        self.PreviousValue = self.Value
        if self.Action then self.Action(self.Value) end
    end
end

function Slider:ToggleDisable()
    self:SetDisabled(not self.Disabled)
end

function Slider:Changed(func)
    self.Action = func
end

function Slider:Pressed(func)
    self.PressedAction = func
end

function Slider:Released(func)
    self.ReleasedAction = func
end

-- Min, Max, Value, Increment, SliderSize, Disabled
function Slider.new(Arguments, Parent)
    local self = GUIObject.new(Arguments, Parent)
    setmetatable(self,Slider)
    self.Increment = self.Arguments.Increment or 0
    self.Value = self.Arguments.Value or self.Arguments.Min
    self.Min = self.Arguments.Min
    self.Max = self.Arguments.Max
    self.SliderFrame = Instance.new("Frame", self.Parent)
    self.SliderFrame.BackgroundTransparency = 1
    self.SlideBar = Instance.new("Frame", self.SliderFrame)
    self.SlideBar.AnchorPoint = Vector2.new(0.5,0.5)
    self.SlideBar.Position = UDim2.new(0.5,0,0.5,0)
    local Size = util.GetScale(self.Arguments.SliderSize) or UDim.new(1,-12)
    self.SlideBar.Size = UDim2.new(Size.Scale, Size.Offset, 0, 5)
    ThemeManager.ColorSync(self.SlideBar, "BackgroundColor3", Enum.StudioStyleGuideColor.FilterButtonAccent)
    self.SlideButton = Instance.new("TextButton", self.SlideBar)
    self.SlideButton.Text = ""
    self.SlideButton.BorderSizePixel = 1
    self.SlideButton.AnchorPoint = Vector2.new(0.5,0.5)
    self:UpdatePosition()
    self.SlideButton.Size = UDim2.new(0,7,0,18)
    ThemeManager.ColorSync(self.SlideButton, "BackgroundColor3", Enum.StudioStyleGuideColor.InputFieldBackground)
    ThemeManager.ColorSync(self.SlideButton, "BorderColor3", Enum.StudioStyleGuideColor.InputFieldBorder)
    self.SlideBar.BorderSizePixel = 0
    self.SliderSelected = false
    self.InitialX = 0
    self.SlideButton.MouseButton1Down:Connect(function(x)
        if self.PressedAction then self.PressedAction() end
        if self.Disabled then return end
        self.SliderSelected = true
        self.InitialX = self.SlideButton.AbsolutePosition.X - x
    end)
    self.SlideButton.MouseButton1Up:Connect(function()
        if self.ReleasedAction then self.ReleasedAction() end
    end)
    self.PreviousValue = self.Value
    InputManager.AddInputEvent("MouseMoved", function(x)
        if not self.SliderSelected then return end
        self.Value = util.RoundNumber(math.clamp((x + self.InitialX - self.SlideBar.AbsolutePosition.X + self.SlideButton.Size.X.Offset / 2)/self.SlideBar.AbsoluteSize.X, 0, 1) * (self.Max - self.Min) + self.Min, self.Increment)
        self:UpdatePosition()
    end)
    InputManager.AddInputEvent("InputEnded", function(p)
        if self.SliderSelected and p.UserInputType == Enum.UserInputType.MouseButton1 then
            self.SliderSelected = false
            if self.ReleasedAction then self.ReleasedAction() end
        end
    end)
    InputManager.AddInputEvent("MouseLeave", function()
        if self.SliderSelected and self.ReleasedAction then self.ReleasedAction() end
        self.SliderSelected = false
    end)
    self.SlideButton.MouseMoved:Connect(function()
        GV.PluginObject:GetMouse().Icon = self.CursorIcon
    end)
    self.SlideButton.MouseLeave:Connect(function()
        task.wait(0)
        GV.PluginObject:GetMouse().Icon = "rbxasset://SystemCursors/Arrow"
    end)
    self:SetDisabled(self.Arguments.Disabled)
    self.Object = self.SlideButton
    self.MainMovable = self.SliderFrame
    return self
end

return Slider]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1CA4A4AE46D94AD7AFE5A810F4430EAE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Textbox</string>
								<string name="ScriptGuid">{47973761-4819-e7e9-a367-1b32673ae9e4}</string>
								<ProtectedString name="Source"><![CDATA[local Textbox = {}
Textbox.__index = Textbox

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local GUIObject = require(GV.ObjectsDir.GUIObject)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
setmetatable(Textbox,GUIObject)

function Textbox:SetDisabled(State)
    self.Disabled = State
    if self.Disabled then
        self.Textbox.TextTransparency = 0.5
    else
        self.Textbox.TextTransparency = 0
    end
end

function Textbox:ToggleDisable()
    self:SetDisabled(not self.Disabled)
end

-- Text, Font, Alignment, TextSize
function Textbox.new(Arguments, Parent)
    local self = GUIObject.new(Arguments, Parent)
    setmetatable(self,Textbox)
    local Alignment = self.Arguments.Alignment or Enum.TextXAlignment.Center
    local Font = self.Arguments.Font or Enum.Font.SourceSans
    local TextSize = self.Arguments.TextSize or self.Arguments.FontSize or 15
    self.Textbox = Instance.new("TextLabel", self.Parent)
    self.Textbox.BackgroundTransparency = 1
    self.Textbox.Size = UDim2.new(1,0,1,0)
    self.Textbox.TextXAlignment = Alignment
    self.Textbox.TextSize = TextSize
    self.Textbox.Font = Font
    self.Textbox.Text = self.Arguments.Text
    ThemeManager.ColorSync(self.Textbox, "TextColor3", Enum.StudioStyleGuideColor.MainText)
    self.Object = self.Textbox
    self.MainMovable = self.Textbox
    return self
end

return Textbox]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX71F7C734E4D94DEE98519F186C082DC7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TitlebarButton</string>
								<string name="ScriptGuid">{c62902e1-ec57-e63a-d6cd-2fc304f8b615}</string>
								<ProtectedString name="Source"><![CDATA[local TitlebarButton = {}
TitlebarButton.__index = TitlebarButton

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local GUIObject = require(GV.ObjectsDir.GUIObject)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
setmetatable(TitlebarButton,GUIObject)

GV.TitleBarButtons = {}

function TitlebarButton:SetDisabled(State)
    self.Disabled = State
    if self.Disabled then
        self.CursorIcon = "rbxasset://SystemCursors/Forbidden"
        for _,v in pairs(self.Buttons) do
            v.Transparency = 0.5
        end
    else
        self.CursorIcon = "rbxasset://SystemCursors/PointingHand"
        for _,v in pairs(self.Buttons) do
            v.Transparency = 0
        end
    end
end

function TitlebarButton:ToggleDisable()
    self:SetDisabled(not self.Disabled)
end

function TitlebarButton:Clicked(func)
    self.Action = func
end

function TitlebarButton:SelectedAction(func)
    self.TitlebarMenuSelectedAction = func
end

function TitlebarButton:CreateCopy(TitlebarMenu)
    local Button = Instance.new("TextButton", TitlebarMenu.ButtonContainer)
    Button = Instance.new("TextButton", TitlebarMenu.ButtonContainer)
    Button.Name = self.Name
    Button.Position = UDim2.new(0,TitlebarMenu.ButtonContainer.Size.X.Offset,1,0)
    ThemeManager.ColorSync(Button, "BackgroundColor3", Enum.StudioStyleGuideColor.Titlebar,nil,nil,nil,true)
    Button.ZIndex = 4
    Button.BorderSizePixel = 0
    Button.Font = Enum.Font.SourceSans
    Button.TextSize = 14
    ThemeManager.ColorSync(Button, "TextColor3", Enum.StudioStyleGuideColor.MainText,nil,nil,nil,true)
    Button.Text = self.Name
    if not self.TabSize then
        local function sync()
            Button.Size = UDim2.new(0,Button.TextBounds.X+1.5*Button.TextSize, 0, 24)
        end
        Button.Changed:Connect(function(p)
            if p == "TextBounds" then sync() end
        end)
    else
        Button.Size = UDim2.new(0,self.TabSize,1,0)
    end
    Button.MouseMoved:Connect(function()
        GV.PluginObject:GetMouse().Icon = self.CursorIcon
    end)
    Button.MouseLeave:Connect(function()
        task.wait(0)
        GV.PluginObject:GetMouse().Icon = "rbxasset://SystemCursors/Arrow"
    end)
    Button.MouseButton1Click:Connect(function()
        if self.Disabled then return end
        if self.Action then self.Action() end
        if self.PluginMenu then
            -- ???? what
            task.wait()
            task.wait()
            -- i have no idea how this works but it does
            local SelectedAction = self.PluginMenu:ShowAsync()
            if self.TitlebarMenuSelectedAction then self.TitlebarMenuSelectedAction(SelectedAction) end
        end
    end)
    self.Buttons[#self.Buttons+1] = Button
end

-- Name, TabSize, Disabled, PluginMenu
function TitlebarButton.new(Arguments)
    local self = GUIObject.new(Arguments)
    setmetatable(self,TitlebarButton)
    self.Buttons = {}
    self.Name = self.Arguments.Name
    self.PluginMenu = self.Arguments.PluginMenu
    self.TabSize = self.Arguments.TabSize
    for _, v in pairs(GV.PluginWidgets) do
        self:CreateCopy(v.TitlebarMenu)
    end
    self:SetDisabled(self.Arguments.Disabled)
    self.Object = self.Buttons
    GV.TitleBarButtons[#GV.TitleBarButtons+1] = self
    return self
end

return TitlebarButton]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE4963C22C7294479A06D40DB03B0CE44">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ToggleableButton</string>
								<string name="ScriptGuid">{d5230742-71a1-11d3-43ae-d6c8a050f374}</string>
								<ProtectedString name="Source"><![CDATA[local ToggleableButton = {}
ToggleableButton.__index = ToggleableButton

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local Button = require(GV.ObjectsDir.Button)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
setmetatable(ToggleableButton,Button)

function ToggleableButton:Update()
    if not self.Value then
        ThemeManager.ColorSync(self.Button, "ImageColor3", Enum.StudioStyleGuideColor.ButtonBorder)
        ThemeManager.ColorSync(self.ButtonBackground, "ImageColor3", Enum.StudioStyleGuideColor.Button)
    else
        ThemeManager.ColorSync(self.Button, "ImageColor3", Enum.StudioStyleGuideColor.ButtonBorder, Enum.StudioStyleGuideModifier.Pressed)
        ThemeManager.ColorSync(self.ButtonBackground, "ImageColor3", Enum.StudioStyleGuideColor.Button, Enum.StudioStyleGuideModifier.Pressed)
    end
end

function ToggleableButton:Toggle()
    self:SetValue(not self.Value)
    return self.Value
end

function ToggleableButton:SetValue(Value)
    self.Value = Value
    self:Update()
end

-- Textbox, Size, Value, Disabled
function ToggleableButton.new(Arguments, Parent)
    local self = Button.new(Arguments, Parent)
    setmetatable(self,ToggleableButton)
    self.Toggleable = true
    local Pressed = false
    self.Button.MouseMoved:Connect(function()
        if self.Disabled or Pressed then return end
        if not self.Value then
            ThemeManager.ColorSync(self.Button, "ImageColor3", Enum.StudioStyleGuideColor.ButtonBorder, Enum.StudioStyleGuideModifier.Hover)
            ThemeManager.ColorSync(self.ButtonBackground, "ImageColor3", Enum.StudioStyleGuideColor.Button, Enum.StudioStyleGuideModifier.Hover)
        else
            ThemeManager.ColorSync(self.Button, "ImageColor3", Enum.StudioStyleGuideColor.InputFieldBorder)
            ThemeManager.ColorSync(self.ButtonBackground, "ImageColor3", Enum.StudioStyleGuideColor.InputFieldBackground)
        end
    end)
    self.Button.MouseLeave:Connect(function()
        if self.Disabled then return end
        Pressed = false
        self:Update()
    end)
    self.Button.MouseButton1Down:Connect(function()
        if self.Disabled then return end
        Pressed = true
        if not self.Value then
            ThemeManager.ColorSync(self.Button, "ImageColor3", Enum.StudioStyleGuideColor.InputFieldBorder)
            ThemeManager.ColorSync(self.ButtonBackground, "ImageColor3", Enum.StudioStyleGuideColor.InputFieldBackground)
        else
            ThemeManager.ColorSync(self.Button, "ImageColor3", Enum.StudioStyleGuideColor.ButtonBorder, Enum.StudioStyleGuideModifier.Pressed)
            ThemeManager.ColorSync(self.ButtonBackground, "ImageColor3", Enum.StudioStyleGuideColor.Button, Enum.StudioStyleGuideModifier.Pressed)
        end
    end)
    
    self.Button.MouseButton1Up:Connect(function()
        if self.Disabled then return end
        Pressed = false
        if not self.Value then
            ThemeManager.ColorSync(self.Button, "ImageColor3", Enum.StudioStyleGuideColor.ButtonBorder, Enum.StudioStyleGuideModifier.Hover)
            ThemeManager.ColorSync(self.ButtonBackground, "ImageColor3", Enum.StudioStyleGuideColor.Button, Enum.StudioStyleGuideModifier.Hover)
        end
    end)

    self.Button.MouseButton1Click:Connect(function()
        if not self.Disabled then
            self:Toggle()
        end
    end)

    self:SetValue(self.Arguments.Value)
    return self
end

return ToggleableButton]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3DE9869AADC04E4DA46109EFB8745CD8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ViewButton</string>
								<string name="ScriptGuid">{043c6ddc-de02-cb8f-abd7-e08e1045b29d}</string>
								<ProtectedString name="Source"><![CDATA[local ChangeHistoryService = game:GetService("ChangeHistoryService")
local GuiService = game:GetService("GuiService")
local ViewButton = {}
ViewButton.__index = ViewButton

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local TitlebarButton = require(GV.ObjectsDir.TitlebarButton)
local InputPrompt = require(GV.PromptsDir.InputPrompt)
local InputField = require(GV.ObjectsDir.InputField)
local ColorInput = require(GV.ObjectsDir.ColorInput)
local Labeled = require(GV.ObjectsDir.Labeled)
local TextPrompt = require(GV.PromptsDir.TextPrompt)
local PluginWidget = require(GV.FramesDir.PluginWidget)
local LayoutManager = require(GV.ManagersDir.LayoutManager)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
setmetatable(ViewButton,TitlebarButton)

local RefreshedMenus = {}

function ViewButton:CreateThemeEditor(func)
    local NewThemePrompt = TextPrompt.new({Title = "Edit Theme", Buttons = {"Save", "Cancel"}, NoPause = true})
    local ThemeColorInput = Labeled.new({
        Object = ColorInput.new({
            Color = ThemeManager.DefaultThemeColor,
            NoPause = true
        }),
        Text = "Theme Color",
        LabelSize = 0.5
    },
    NewThemePrompt.TextPromptContainer)
    ThemeColorInput.Object:SetValue(ThemeManager.ThemeColor)
    ThemeColorInput.Object:Changed(function(p)
        ThemeManager.ReloadTheme(p, ThemeManager.CurrentAccent)
    end)
    ThemeColorInput.MainFrame.Size = UDim2.new(1,0,0,28)
    local AccentColorInput = Labeled.new({
        Object = ColorInput.new({
            Color = ThemeManager.DefaultAccentColor,
            NoPause = true
        }),
        Text = "Accent Color",
        LabelSize = 0.5
    },
    NewThemePrompt.TextPromptContainer)
    AccentColorInput.Object:SetValue(ThemeManager.AccentColor)
    AccentColorInput.Object:Changed(function(p)
        ThemeManager.ReloadTheme(ThemeManager.CurrentTheme, p)
    end)
    AccentColorInput.MainFrame.Size = UDim2.new(1,0,0,28)
    NewThemePrompt.Textbox:Destroy()
    NewThemePrompt.TextFrame.Size = UDim2.new(0,0,0,10)
    NewThemePrompt.ButtonsFrame.Parent = nil
    NewThemePrompt.ButtonsFrame.Parent = NewThemePrompt.TextPromptContainer
    NewThemePrompt:Clicked(function(p) if func then func(p) end end)
end

function ViewButton:LoadWidgetOption(Widget, i)
    local WidgetTitle = Widget.WidgetObject.Title
    local WidgetMenuObject = GV.PluginObject:CreatePluginMenu(game:GetService("HttpService"):GenerateGUID(false), tostring(i) .. ': "' .. WidgetTitle .. '"')
    WidgetMenuObject.Name = '"' .. WidgetTitle .. '" Widget Menu'
    local ToggleAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Toggle", "", nil, false)
    local RenameAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Rename", "", nil, false)
    local DeleteAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Delete", "", nil, false)
    ToggleAction.Triggered:Connect(function()
        Widget.WidgetObject.Enabled = not Widget.WidgetObject.Enabled
    end)
    RenameAction.Triggered:Connect(function()
        Widget:Rename()
    end)
    DeleteAction.Triggered:Connect(function()
        Widget:Delete()
    end)
    WidgetMenuObject:AddAction(ToggleAction)
    WidgetMenuObject:AddAction(RenameAction)
    WidgetMenuObject:AddSeparator()
    WidgetMenuObject:AddAction(DeleteAction)
    ToggleAction.Parent = WidgetMenuObject
    RenameAction.Parent = WidgetMenuObject
    DeleteAction.Parent = WidgetMenuObject
    return WidgetMenuObject
end

function ViewButton:LoadLayoutOption(Layout, i)
    if not Layout.Name then Layout.Name = "Unnamed" end
    local SavedLayouts = GV.PluginObject:GetSetting(GV.PluginID.."SavedGUILayouts") or {}
    local LayoutMenuObject = GV.PluginObject:CreatePluginMenu(game:GetService("HttpService"):GenerateGUID(false), tostring(i) .. ': "' .. Layout.Name .. '"')
    LayoutMenuObject.Name = '"' .. Layout.Name .. '" Layout Menu'
    local UseLayoutAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Use", "", nil, false)
    local SaveAsAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Save As", "", nil, false)
    local RenameAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Rename", "", nil, false)
    local DeleteAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Delete", "", nil, false)
    UseLayoutAction.Triggered:Connect(function()
        local OverridePrompt = TextPrompt.new({Title = "Override Layout", Text = "Are you sure you want to override the current GUI layout?", Buttons = {"Yes", "No"}})
        OverridePrompt:Clicked(function(p)
            if p == 2 or p == 0 then return end
            LayoutManager.RecallLayout(Layout)
        end)
    end)
    SaveAsAction.Triggered:Connect(function()
        local CurrentLayout = LayoutManager.GetLayout()
        CurrentLayout.Name = Layout.Name
        SavedLayouts[i] = CurrentLayout
        GV.PluginObject:SetSetting(GV.PluginID.."SavedGUILayouts", SavedLayouts)
    end)
    RenameAction.Triggered:Connect(function()
        local RenamePrompt = InputPrompt.new({Title = "Rename Layout ", Text = "Type in a new name:", Buttons = {"OK", "Cancel"}, InputField = InputField.new({Placeholder = "New name", Value = Layout.Name, NoDropdown = true, Unpausable = true})})
        RenamePrompt:Clicked(function(p)
            if p == 2 or p == 0 then return end
            Layout.Name = RenamePrompt.Input.Text
            SavedLayouts[i] = Layout
            GV.PluginObject:SetSetting(GV.PluginID.."SavedGUILayouts", SavedLayouts)
        end)
    end)
    DeleteAction.Triggered:Connect(function()
        local DeletePrompt = TextPrompt.new({Title = "Delete " .. Layout.Name, Text = 'Are you sure you want to delete "' .. Layout.Name .. '"?', Buttons = {"Yes", "No"}})
        DeletePrompt:Clicked(function(p)
            if p == 2 or p == 0 then return end
            table.remove(SavedLayouts, i)
            GV.PluginObject:SetSetting(GV.PluginID.."SavedGUILayouts", SavedLayouts)
        end)
    end)
    LayoutMenuObject:AddAction(UseLayoutAction)
    LayoutMenuObject:AddAction(SaveAsAction)
    LayoutMenuObject:AddAction(RenameAction)
    LayoutMenuObject:AddSeparator()
    LayoutMenuObject:AddAction(DeleteAction)
    UseLayoutAction.Parent = LayoutMenuObject
    SaveAsAction.Parent = LayoutMenuObject
    RenameAction.Parent = LayoutMenuObject
    DeleteAction.Parent = LayoutMenuObject
    return LayoutMenuObject
end

function ViewButton:LoadThemeOption(Theme, i)
    local SavedThemes = GV.PluginObject:GetSetting("SavedGUIThemes") or ThemeManager.PreinstalledThemes
    local ThemeMenuObject = GV.PluginObject:CreatePluginMenu(game:GetService("HttpService"):GenerateGUID(false), tostring(i) .. ': "' .. Theme.Name .. '"')
    ThemeMenuObject.Name = '"' .. Theme.Name .. '" Theme Menu'
    local UseThemeAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Use", "", nil, false)
    local EditAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Edit", "", nil, false)
    local RenameAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Rename", "", nil, false)
    local DeleteAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Delete", "", nil, false)
    UseThemeAction.Triggered:Connect(function()
        local OverridePrompt = TextPrompt.new({Title = "Override Theme", Text = "Are you sure you want to override the current GUI theme?", Buttons = {"Yes", "No"}})
        OverridePrompt:Clicked(function(p)
            if p == 2 or p == 0 then return end
            ThemeManager.UpdateTheme(util.TableToColor3(Theme.Theme), util.TableToColor3(Theme.Accent))
        end)
    end)
    EditAction.Triggered:Connect(function()
        self:CreateThemeEditor(function(p)
            if p == 2 or p == 0 then ThemeManager.ReloadTheme(ThemeManager.ThemeColor, ThemeManager.AccentColor)  return end
            ThemeManager.UpdateTheme()
            SavedThemes[i] = {["Name"] = Theme.Name, ["Theme"] = util.Color3ToTable(ThemeManager.ThemeColor), ["Accent"] = util.Color3ToTable(ThemeManager.AccentColor)}
            GV.PluginObject:SetSetting("SavedGUIThemes", SavedThemes)
        end)
    end)
    RenameAction.Triggered:Connect(function()
        local RenamePrompt = InputPrompt.new({Title = "Rename Theme", Text = "Type in a new name:", Buttons = {"OK", "Cancel"}, InputField = InputField.new({Placeholder = "New name", Value = Theme.Name, NoDropdown = true, Unpausable = true})})
        RenamePrompt:Clicked(function(p)
            if p == 2 or p == 0 then return end
            Theme.Name = RenamePrompt.Input.Text
            SavedThemes[i] = Theme
            GV.PluginObject:SetSetting("SavedGUIThemes", SavedThemes)
        end)
    end)
    DeleteAction.Triggered:Connect(function()
        local DeletePrompt = TextPrompt.new({Title = "Delete " .. Theme.Name, Text = 'Are you sure you want to delete "' .. Theme.Name .. '"?', Buttons = {"Yes", "No"}})
        DeletePrompt:Clicked(function(p)
            if p == 2 or p == 0 then return end
            table.remove(SavedThemes, i)
            GV.PluginObject:SetSetting("SavedGUIThemes", SavedThemes)
        end)
    end)
    ThemeMenuObject:AddAction(UseThemeAction)
    ThemeMenuObject:AddAction(EditAction)
    ThemeMenuObject:AddAction(RenameAction)
    ThemeMenuObject:AddSeparator()
    ThemeMenuObject:AddAction(DeleteAction)
    UseThemeAction.Parent = ThemeMenuObject
    EditAction.Parent = ThemeMenuObject
    RenameAction.Parent = ThemeMenuObject
    DeleteAction.Parent = ThemeMenuObject
    return ThemeMenuObject
end

function ViewButton:CreateMenu()
    self.PluginMenu = GV.PluginObject:CreatePluginMenu(game:GetService("HttpService"):GenerateGUID(false), "View Menu")
    self.PluginMenu.Name = "View Menu"

    -- Saved Layouts Menu
    self.LayoutsMenu = GV.PluginObject:CreatePluginMenu(game:GetService("HttpService"):GenerateGUID(false), "Layouts")
    self.LayoutsMenu.Name = "Layout Menu"
    local SaveCurrentLayout = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Save Layout", "", nil, false)
    SaveCurrentLayout.Triggered:Connect(function()
        local SavedLayouts = GV.PluginObject:GetSetting(GV.PluginID.."SavedGUILayouts") or {}
        local NamePrompt = InputPrompt.new({Title = "Name Layout ", Text = "Type in a name for this layout:", Buttons = {"OK", "Cancel"}, InputField = InputField.new({Placeholder = "New name", NoDropdown = true, Unpausable = true})})
        NamePrompt:Clicked(function(p)
            if p == 2 or p == 0 then return end
            local NewLayout = LayoutManager.GetLayout()
            NewLayout.Name = NamePrompt.Input.Text
            SavedLayouts[#SavedLayouts+1] = NewLayout
            GV.PluginObject:SetSetting(GV.PluginID.."SavedGUILayouts", SavedLayouts)
        end)
    end)
    local ResetLayoutAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Reset Layout", "", nil, false)
    ResetLayoutAction.Triggered:Connect(function()
        local OverridePrompt = TextPrompt.new({Title = "Override Layout", Text = "Are you sure you want to override the current GUI layout?", Buttons = {"Yes", "No"}})
        OverridePrompt:Clicked(function(p)
            if p == 2 or p == 0 then return end
            LayoutManager.ResetLayout()
        end)
    end)
    self.LayoutsMenu:AddAction(SaveCurrentLayout)
    self.LayoutsMenu:AddAction(ResetLayoutAction)
    self.LayoutsMenu:AddSeparator()
    SaveCurrentLayout.Parent = self.LayoutsMenu
    ResetLayoutAction.Parent = self.LayoutsMenu
    self.PluginMenu:AddMenu(self.LayoutsMenu)

    -- Widgets Menu
    self.WidgetsMenu = GV.PluginObject:CreatePluginMenu(game:GetService("HttpService"):GenerateGUID(false), "Widgets")
    self.WidgetsMenu.Name = "Widget Menu"
    local CreateNewWindowAction = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "Create New Window", "", nil, false)
    CreateNewWindowAction.Triggered:Connect(function()
        PluginWidget.new({Enabled = true})
    end)
    self.WidgetsMenu:AddAction(CreateNewWindowAction)
    self.WidgetsMenu:AddSeparator()
    CreateNewWindowAction.Parent = self.WidgetsMenu
    self.LayoutsMenu:AddMenu(self.WidgetsMenu)
    self.LayoutsMenu:AddSeparator()

    -- Appearance/Themes
    self.ThemesMenu = GV.PluginObject:CreatePluginMenu(game:GetService("HttpService"):GenerateGUID(false), "Themes")
    self.ThemesMenu.Name = "Themes Menu"
    local NewTheme = GV.PluginObject:CreatePluginAction(game:GetService("HttpService"):GenerateGUID(false), "New Theme", "", nil, false)
    NewTheme.Triggered:Connect(function()
        self:CreateThemeEditor(function(p)
            if p == 2 or p == 0 then ThemeManager.ReloadTheme(ThemeManager.ThemeColor, ThemeManager.AccentColor) return end
            ThemeManager.UpdateTheme()
            local NamePrompt = InputPrompt.new({Title = "Name Layout ", Text = "Type in a name for this theme:", Buttons = {"OK", "Cancel"}, InputField = InputField.new({Placeholder = "New name", NoDropdown = true, Unpausable = true})})
            NamePrompt:Clicked(function(p)
                if p == 2 or p == 0 then return end
                local SavedThemes = GV.PluginObject:GetSetting("SavedGUIThemes") or ThemeManager.PreinstalledThemes
                SavedThemes[#SavedThemes+1] = {Name = NamePrompt.Input.Text, Theme = util.Color3ToTable(ThemeManager.CurrentTheme), Accent = util.Color3ToTable(ThemeManager.CurrentAccent)}
                GV.PluginObject:SetSetting("SavedGUIThemes", SavedThemes)
            end)
        end)
    end)
    self.ThemesMenu:AddAction(NewTheme)
    self.ThemesMenu:AddSeparator()
    self.PluginMenu:AddMenu(self.ThemesMenu)
    
end

function ViewButton:RefreshMenu()
    for _, v in pairs(RefreshedMenus) do
        v:Destroy()
    end
    RefreshedMenus = {}
    for i,Widget in pairs(GV.PluginWidgets) do
        local LoadedOption = self:LoadWidgetOption(Widget, i)
        RefreshedMenus[#RefreshedMenus+1] = LoadedOption
        self.WidgetsMenu:AddMenu(LoadedOption)
    end
    local SavedLayouts = GV.PluginObject:GetSetting(GV.PluginID.."SavedGUILayouts") or {}
    for i,Layout in pairs(SavedLayouts) do
        local LoadedOption = self:LoadLayoutOption(Layout, i)
        RefreshedMenus[#RefreshedMenus+1] = LoadedOption
        self.LayoutsMenu:AddMenu(LoadedOption)
    end
    local SavedThemes = GV.PluginObject:GetSetting("SavedGUIThemes") or ThemeManager.PreinstalledThemes
    for i,Theme in pairs(SavedThemes) do
        local LoadedTheme = self:LoadThemeOption(Theme, i)
        RefreshedMenus[#RefreshedMenus+1] = LoadedTheme
        self.ThemesMenu:AddMenu(LoadedTheme)
    end
end

function ViewButton.new()
    local self = TitlebarButton.new({Name = "VIEW"})
    setmetatable(self,ViewButton)
    self:CreateMenu()
    self:Clicked(function()
        self:RefreshMenu()
    end)
    return self
end

return ViewButton]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX93F8992112D045F19F656A4E131B50CF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PluginGlobalVariables</string>
							<string name="ScriptGuid">{59a3c265-9058-fb9b-220a-958b42ac1cc8}</string>
							<ProtectedString name="Source"><![CDATA[local m = {}
m.LibraryDir = script.Parent
m.FramesDir = m.LibraryDir.Frames
m.ObjectsDir = m.LibraryDir.Objects
m.ManagersDir = m.LibraryDir.Managers
m.PromptsDir = m.LibraryDir.Prompts
m.MiscDir = m.LibraryDir.Misc

return m]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXCE8ECE3120F549129256B9F5630196AC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<string name="Name">Prompts</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXF882E0A0E5AE4E6EA7807B3FD2ADA164">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ColorPrompt</string>
								<string name="ScriptGuid">{3781ee12-8358-815d-5cb2-e437e0b9c60e}</string>
								<ProtectedString name="Source"><![CDATA[local ColorPrompt = {}
ColorPrompt.__index = ColorPrompt

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local Prompt = require(GV.PromptsDir.Prompt)
local InputField = require(GV.ObjectsDir.InputField)
local ThemeManager = require(GV.ManagersDir.ThemeManager)
local Button = require(GV.ObjectsDir.Button)

setmetatable(ColorPrompt, Prompt)

ColorPrompt.Images = {
    PalateIndicator = "http://www.roblox.com/asset/?id=10773265480",
    HueIndicator = "http://www.roblox.com/asset/?id=9666389442"
}

function ColorPrompt:UpdatePreview()
    self.ColorGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0,Color3.new(1,1,1)),
        ColorSequenceKeypoint.new(1,Color3.fromHSV(self.HSVValue.H,1,1))
    }
    self.ColorPreview.BackgroundColor3 = self.Value
end

function ColorPrompt:SetPalatePos(X,Y)
    self.PalateIndicator.Position = UDim2.fromScale(X,Y)
    self.HSVValue.S = X
    self.HSVValue.V = 1-Y
    self:SetValue(Color3.fromHSV(self.HSVValue.H, self.HSVValue.S, self.HSVValue.V),false,true)
    self:UpdatePreview()
end

function ColorPrompt:SetHuePos(Y)
    self.LeftHueIndicator.Position = UDim2.fromScale(0,Y)
    self.RightHueIndicator.Position = UDim2.fromScale(1,Y)
    self.HSVValue.H = 1-Y
    self:SetValue(Color3.fromHSV(self.HSVValue.H, self.HSVValue.S, self.HSVValue.V),false,true)
    self:UpdatePreview()
end

function ColorPrompt:SetValue(Value, IgnoreText, IgnoreHSV)
    self.Value = Value or self.Value
    local hue, sat, val = self.Value:ToHSV()
    if not IgnoreHSV then
        self.HSVValue = {H = hue, S = sat, V = val}
    end
    self.PalateIndicator.Position = UDim2.fromScale(self.HSVValue.S, 1-self.HSVValue.V)
    self.LeftHueIndicator.Position = UDim2.fromScale(0,1-self.HSVValue.H)
    self.RightHueIndicator.Position = UDim2.fromScale(1,1-self.HSVValue.H)
    if not IgnoreText then
        self.RGBInput.Input.Text = util.Color3ToText(self.Value)
        self.HexInput.Input.Text = "#"..self.Value:ToHex()
    end
    if self.ChangedAction then self.ChangedAction(self.Value) end
    self:UpdatePreview()
end

function ColorPrompt:Changed(func)
    self.ChangedAction = func
end

function ColorPrompt:Done(func)
    self.DoneAction = func
end

-- Color/Value
function ColorPrompt.new(Arguments)
    Arguments.Title = "Pick a Color"
    Arguments.Width = 430
    Arguments.Height = 315
    local self = Prompt.new(Arguments)
    setmetatable(self,ColorPrompt)
    self.ColorComponents = Instance.new("Frame", self.Parent)
    self.ColorComponents.Name = "ColorComponents"
    self.ColorComponents.BackgroundTransparency = 1
    self.ColorComponents.Position = UDim2.fromOffset(15,30)
    self.ColorComponents.Size = UDim2.fromOffset(285,255)
    self.ColorPalate = Instance.new("Frame", self.ColorComponents)
    self.ColorPalate.Name = "ColorPalate"
    self.ColorPalate.Size = UDim2.fromOffset(255,255)
    self.ColorPalate.BackgroundTransparency = 1
    self.ColorGraidentFrame = Instance.new("Frame", self.ColorComponents)
    self.ColorGraidentFrame.Size = UDim2.fromOffset(255,255)
    self.ColorGraidentFrame.BackgroundColor3 = Color3.new(1,1,1)
    self.ColorGraidentFrame.BorderSizePixel = 0
    self.ColorGradient = Instance.new("UIGradient", self.ColorGraidentFrame)
    self.LightnessGradientFrame = Instance.new("Frame", self.ColorComponents)
    self.LightnessGradientFrame.Size = UDim2.fromOffset(255,255)
    self.LightnessGradientFrame.BackgroundColor3 = Color3.new(1,1,1)
    self.LightnessGradientFrame.BackgroundTransparency = 0
    self.LightnessGradientFrame.BorderSizePixel = 0
    self.LightnessGradient = Instance.new("UIGradient", self.LightnessGradientFrame)
    self.LightnessGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.new(0)),
        ColorSequenceKeypoint.new(1, Color3.new(0)),
    })
    self.LightnessGradient.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 1),
    })
    self.LightnessGradient.Rotation = -90
    self.PalateIndicator = Instance.new("ImageLabel", self.ColorPalate)
    self.PalateIndicator.Name = "PalateIndicator"
    self.PalateIndicator.Image = self.Images.PalateIndicator
    self.PalateIndicator.AnchorPoint = Vector2.new(0.5, 0.5)
    self.PalateIndicator.BackgroundTransparency = 1
    self.PalateIndicator.Size = UDim2.fromOffset(15,15)
    self.PalateIndicator.ZIndex = 2
    local MouseDownPalate = false
    self.ColorPalate.InputBegan:Connect(function(p)
        if p.UserInputType == Enum.UserInputType.MouseButton1 then
            self:SetPalatePos((p.Position.X-self.ColorPalate.AbsolutePosition.X)/self.ColorPalate.AbsoluteSize.X, (p.Position.Y-self.ColorPalate.AbsolutePosition.Y)/self.ColorPalate.AbsoluteSize.Y)
            MouseDownPalate = true
        end
    end)
    self.ColorPalate.InputEnded:Connect(function(p)
        if p.UserInputType == Enum.UserInputType.MouseButton1 then
            MouseDownPalate = false
        end
    end)
    self.HueGradientFrame = Instance.new("Frame", self.ColorComponents)
    self.HueGradientFrame.Name = "HueGradient"
    self.HueGradientFrame.AnchorPoint = Vector2.new(1, 0)
    self.HueGradientFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    self.HueGradientFrame.BorderSizePixel = 0
    self.HueGradientFrame.Position = UDim2.fromScale(1, 0)
    self.HueGradientFrame.Size = UDim2.new(0, 20, 1, 0)

    self.HueGradient = Instance.new("UIGradient", self.HueGradientFrame)
    self.HueGradient.Name = "UIGradient"
    self.HueGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
        ColorSequenceKeypoint.new(1/6, Color3.fromRGB(255, 0, 255)),
        ColorSequenceKeypoint.new(1/3, Color3.fromRGB(0, 0, 255)),
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 255)),
        ColorSequenceKeypoint.new(2/3, Color3.fromRGB(0, 255, 0)),
        ColorSequenceKeypoint.new(5/6, Color3.fromRGB(255, 255, 0)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0)),
    })
    self.HueGradient.Rotation = 90

    self.LeftHueIndicator = Instance.new("ImageLabel", self.HueGradientFrame)
    self.LeftHueIndicator.Name = "LeftIndicator"
    self.LeftHueIndicator.Image = self.Images.HueIndicator
    ThemeManager.ColorSync(self.LeftHueIndicator, "ImageColor3", Enum.StudioStyleGuideColor.MainText)
    self.LeftHueIndicator.AnchorPoint = Vector2.new(1, 0.5)
    self.LeftHueIndicator.BackgroundTransparency = 1
    self.LeftHueIndicator.Rotation = -90
    self.LeftHueIndicator.Size = UDim2.fromOffset(10, 10)

    self.RightHueIndicator = Instance.new("ImageLabel", self.HueGradientFrame)
    self.RightHueIndicator.Name = "RightIndicator"
    self.RightHueIndicator.Image = self.Images.HueIndicator
    ThemeManager.ColorSync(self.RightHueIndicator, "ImageColor3", Enum.StudioStyleGuideColor.MainText)
    self.RightHueIndicator.AnchorPoint = Vector2.new(0, 0.5)
    self.RightHueIndicator.BackgroundTransparency = 1
    self.RightHueIndicator.Rotation = 90
    self.RightHueIndicator.Size = UDim2.fromOffset(10, 10)

    local MouseDownHueGradient = false
    self.HueGradientFrame.InputBegan:Connect(function(p)
        if p.UserInputType == Enum.UserInputType.MouseButton1 then
            self:SetHuePos(math.clamp((p.Position.Y-self.HueGradientFrame.AbsolutePosition.Y)/self.HueGradientFrame.AbsoluteSize.Y,0,1))
            MouseDownHueGradient = true
        end
    end)
    self.HueGradientFrame.InputEnded:Connect(function(p)
        if p.UserInputType == Enum.UserInputType.MouseButton1 then
            MouseDownHueGradient = false
        end
    end)

    self.Parent.MouseMoved:Connect(function(x,y)
        if MouseDownPalate then
            self:SetPalatePos(math.clamp((x-self.ColorPalate.AbsolutePosition.X)/self.ColorPalate.AbsoluteSize.X, 0, 1), math.clamp((y-self.ColorPalate.AbsolutePosition.Y)/self.ColorPalate.AbsoluteSize.Y, 0, 1))
        elseif MouseDownHueGradient then
            self:SetHuePos(math.clamp((y-self.HueGradientFrame.AbsolutePosition.Y)/self.HueGradientFrame.AbsoluteSize.Y, 0, 1))
        end
    end)

    self.ColorPickerOptions = Instance.new("Frame", self.Parent)
    self.ColorPickerOptions.Name = "Color PIcker Options"
    self.ColorPickerOptions.BackgroundTransparency = 1
    self.ColorPickerOptions.Position = UDim2.fromOffset(315, 30)
    self.ColorPickerOptions.Size = UDim2.fromOffset(100, 250)

    self.ColorPreview = Instance.new("Frame", self.ColorPickerOptions)
    self.ColorPreview.Name = "ColorPreview"
    self.ColorPreview.AnchorPoint = Vector2.new(0.5, 0.5)
    ThemeManager.ColorSync(self.ColorPreview, "BorderColor3", Enum.StudioStyleGuideColor.Border)
    self.ColorPreview.Position = UDim2.fromOffset(50, 42)
    self.ColorPreview.Size = UDim2.fromOffset(75, 75)

    self.RGBInput = InputField.new({NoDropdown = true, ClearBackground = true, Unpausable = true}, self.ColorPickerOptions)
    self.RGBInput.Name = "RGBInput"
    self.RGBInput.InputFieldContainer.AnchorPoint = Vector2.new(0.5,0.5)
    self.RGBInput.InputFieldContainer.Position = UDim2.fromOffset(50,97)
    self.RGBInput.InputFieldContainer.Size = UDim2.new(0,100,0,20)
    self.RGBInput.InputFieldFrame.Size = UDim2.new(1,0,1,0)
    self.RGBInput.Input.TextXAlignment = Enum.TextXAlignment.Center
    self.RGBInput:Changed(function(p)
        self:SetValue(util.TextToColor3(p), true)
    end)
    self.RGBInput:LostFocus(function(p)
        self:SetValue(util.TextToColor3(p))
        self.RGBInput.Input.TextXAlignment = Enum.TextXAlignment.Center
    end)
    self.RGBInput:GainedFocus(function()
        self.RGBInput.Input.TextXAlignment = Enum.TextXAlignment.Left
        ThemeManager.ColorSync(self.RGBInput.InputFieldFrame, "BackgroundColor3", Enum.StudioStyleGuideColor.InputFieldBackground)
    end)

    self.HexInput = InputField.new({NoDropdown = true, ClearBackground = true, Unpausable = true}, self.ColorPickerOptions)
    self.HexInput.Name = "HexInput"
    self.HexInput.InputFieldContainer.AnchorPoint = Vector2.new(0.5,0.5)
    self.HexInput.InputFieldContainer.Position = UDim2.fromOffset(50,122)
    self.HexInput.InputFieldContainer.Size = UDim2.new(0,100,0,20)
    self.HexInput.InputFieldFrame.Size = UDim2.new(1,0,1,0)
    self.HexInput.Input.TextXAlignment = Enum.TextXAlignment.Center
    self.HexInput:Changed(function(p)
        local newhex = string.match(p:gsub('#',''), "^%x%x%x%x%x%x$")
        if newhex then self:SetValue(Color3.fromHex(newhex), true) end
    end)
    self.HexInput:LostFocus(function(p)
        local newhex = string.match(p:gsub('#',''), "^%x%x%x%x%x%x$")
        if newhex then self:SetValue(Color3.fromHex(newhex))
        else self:SetValue() end
        self.HexInput.Input.TextXAlignment = Enum.TextXAlignment.Center
    end)
    self.HexInput:GainedFocus(function()
        self.HexInput.Input.TextXAlignment = Enum.TextXAlignment.Left
    end)

    self.OKButton = Button.new({Text = "OK", ButtonSize = 1, Unpausable = true}, self.ColorPickerOptions)
    self.OKButton.ButtonFrame.AnchorPoint = Vector2.new(0.5,0.5)
    self.OKButton.ButtonFrame.Size = UDim2.fromOffset(100,25)
    self.OKButton.ButtonFrame.Position = UDim2.fromOffset(50,210)

    self.OKButton:Clicked(function()
        self:Destroy()
        if self.DoneAction then self.DoneAction(self.Value) end
    end)

    self.CancelButton = Button.new({Text = "Cancel", ButtonSize = 1, Unpausable = true}, self.ColorPickerOptions)
    self.CancelButton.ButtonFrame.AnchorPoint = Vector2.new(0.5,0.5)
    self.CancelButton.ButtonFrame.Size = UDim2.fromOffset(100,25)
    self.CancelButton.ButtonFrame.Position = UDim2.fromOffset(50,235)

    self.CancelButton:Clicked(function()
        self:Destroy()
        if self.DoneAction then self.DoneAction(self.OriginalValue) end
    end)
    self:OnWindowClose(function()
        self:Destroy()
        if self.DoneAction then self.DoneAction(self.OriginalValue) end
    end)

    self:SetValue(self.Arguments.Value or self.Arguments.Color or Color3.new(1,1,1))
    self.OriginalValue = self.Value
    return self
end

return ColorPrompt]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXBB005861ACC848D1827AD383B1890D9D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">InputPrompt</string>
								<string name="ScriptGuid">{08668509-77ab-c9b1-dd79-47d184401457}</string>
								<ProtectedString name="Source"><![CDATA[local InputPrompt = {}
InputPrompt.__index = InputPrompt

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local TextPrompt = require(GV.PromptsDir.TextPrompt)
local InputFieldMod = require(GV.ObjectsDir.InputField)

setmetatable(InputPrompt, TextPrompt)

-- Title, Textbox, Buttons, InputField
function InputPrompt.new(Arguments)
    local self = TextPrompt.new(Arguments)
    setmetatable(self,InputPrompt)
    local InputField = self.Arguments.InputField or self.Arguments.Input
    if type(InputField) == "string" then
        self.InputField = InputFieldMod.new({Placeholder = InputField, InputSize = UDim.new(1,-30), NoDropdown = true, Unpausable = true})
    else
        self.InputField = InputField
    end
    self.InputField.Arguments.Unpausable = true
    self.InputField.InputFieldContainer.Size = UDim2.new(1,0,0,25)
    self.InputField.DropdownMaxY = 30
    self.ButtonsFrame.Parent = nil
    self.InputField:Move(self.TextPromptContainer, true)
    self.ButtonsFrame.Parent = self.TextPromptContainer
    self.Input = self.InputField.Input
    return self
end

return InputPrompt]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX48A5A2216EF34AAEBB90C68571447FA1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Prompt</string>
								<string name="ScriptGuid">{611dd3b4-8dfd-997f-4f35-19026e96aa84}</string>
								<ProtectedString name="Source"><![CDATA[local Prompt = {}
Prompt.__index = Prompt

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local BackgroundFrame = require(GV.FramesDir.BackgroundFrame)
local GUIElement = require(GV.LibraryDir.GUIElement)
local ResetThreshold = 5
setmetatable(Prompt,GUIElement)

function Prompt:Destroy()
    if not self.Arguments.NoPause then util.UnpauseAll() end
    self.Widget:Destroy()
end

function Prompt:OnWindowClose(func)
    self.CloseAction = func
end

function Prompt:Reset(Title, Width, Height)
    if self.Resetting then return end
    self.Resetting = true
    Title = Title or "Prompt"
    if not Width or Width < 1 then Width = 260 end
    if not Height or Height < 1 then Height = 75 end
    local NewWidget = GV.PluginObject:CreateDockWidgetPluginGui(game:GetService("HttpService"):GenerateGUID(false), DockWidgetPluginGuiInfo.new(Enum.InitialDockState.Float, true, true, Width+2, Height+24,1,1))
    if self.Widget then for _,v in pairs(self.Widget:GetChildren())do
        v.Parent = NewWidget
    end self.Widget:Destroy() end
    NewWidget.Title = Title
    NewWidget.Changed:Connect(function(p)
        if p == "AbsoluteSize" then
            if NewWidget.AbsoluteSize.X ~= Width or NewWidget.AbsoluteSize.Y ~= Height then
                if not self.ResetCounter or self.ResetCounter < ResetThreshold then
                    self.ResetCounter = (self.ResetCounter or 0) + 1
                    self:Reset(Title, Width, Height)
                end
            end
        elseif p == "Enabled" then
            NewWidget.Enabled = true
            if self.CloseAction then self.CloseAction() end
        end
    end)
    self.Widget = NewWidget
    self.Resetting = false
end

-- Title, Width, Height, NoPause
function Prompt.new(Arguments)
    local self = GUIElement.new(Arguments)
    setmetatable(self,Prompt)
    self:Reset(self.Arguments.Title, self.Arguments.Width, self.Arguments.Height)
    if not self.Arguments.NoPause then util.PauseAll() end
    local BackgroundFrame = BackgroundFrame.new(nil, self.Widget)
    self.Parent = BackgroundFrame.Content
    return self
end

return Prompt]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFFFE66EC12824E4793D08909E8C31036">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TextPrompt</string>
								<string name="ScriptGuid">{76b90b53-e839-6d18-9437-a6ed49977a7e}</string>
								<ProtectedString name="Source"><![CDATA[local TextPrompt = {}
TextPrompt.__index = TextPrompt

local GV = require(script.Parent.Parent.PluginGlobalVariables)
local util = require(GV.MiscDir.GUIUtil)
local Prompt = require(GV.PromptsDir.Prompt)
local TextboxMod = require(GV.ObjectsDir.Textbox)
local Button = require(GV.ObjectsDir.Button)
setmetatable(TextPrompt, Prompt)

function TextPrompt:Clicked(func)
    self.Action = func
end

-- Title, Textbox/Text, Buttons
function TextPrompt.new(Arguments)
    local self = Prompt.new(Arguments)
    setmetatable(self,TextPrompt)
    local Buttons = self.Arguments.Buttons or {"OK"}
    self.TextPromptContainer = Instance.new("Frame", self.Parent)
    self.TextPromptContainer.BackgroundTransparency = 1
    self.TextPromptContainer.BorderSizePixel = 0
    self.TextPromptContainer.Size = UDim2.new(0,self.Parent.AbsoluteSize.X,0,self.Parent.AbsoluteSize.Y)
    self.TextPromptContainer.Name = "TextPromptContainer"
    self.TextPromptLayout = Instance.new("UIListLayout", self.TextPromptContainer)
    self.TextPromptLayout.SortOrder = Enum.SortOrder.LayoutOrder
    self.TextFrame = Instance.new("Frame", self.TextPromptContainer)
    self.TextFrame.Name = "TextFrame"
    self.TextFrame.Size = UDim2.new(0,0,0,35)
    self.TextFrame.BackgroundTransparency = 1
    self.TextFrame.BorderSizePixel = 0
    self.TextboxTable = self.Arguments.Textbox or self.Arguments.Text
    if type(self.TextboxTable) == "string" or not self.TextboxTable then
        self.TextboxTable = TextboxMod.new({Text = self.TextboxTable or ""}, self.TextFrame)
    else
        self.TextboxTable:Move(self.TextFrame, true)
    end
    self.TextboxTable.Arguments.Unpausable = true
    self.Textbox = self.TextboxTable.Textbox
    self.Textbox.ZIndex = 1
    self.Textbox.TextXAlignment = Enum.TextXAlignment.Left
    self.Textbox.AnchorPoint = Vector2.new(0.5,0.5)
    self.Textbox.Position = UDim2.new(0.5,0,0.6,0)
    self.Textbox.Size = UDim2.new(1,-24,0,14)
    self.ButtonsFrame = Instance.new("Frame", self.TextPromptContainer)
    self.ButtonsFrame.Name = "ButtonsFrame"
    self.ButtonsFrame.Size = UDim2.new(1,0,0,40)
    self.ButtonsFrame.BackgroundTransparency = 1
    self.ButtonsFrame.BorderSizePixel = 0
    local ButtonsFramePadding = Instance.new("UIPadding", self.ButtonsFrame)
    ButtonsFramePadding.PaddingBottom, ButtonsFramePadding.PaddingLeft, ButtonsFramePadding.PaddingRight, ButtonsFramePadding.PaddingTop = UDim.new(0,7), UDim.new(0,7), UDim.new(0,7), UDim.new(0,7)
    self.ButtonsFrameLayout = Instance.new("UIListLayout", self.ButtonsFrame)
    self.ButtonsFrameLayout.FillDirection = Enum.FillDirection.Horizontal
    self.ButtonsFrameLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
    self.ButtonsFrameLayout.SortOrder = Enum.SortOrder.LayoutOrder
    self:OnWindowClose(function()
        self:Destroy()
        if self.Action then self.Action(0) end
    end)
    if (#Buttons*82)+14 > 260 then
        self.ButtonsFrame.Size = UDim2.new(0,(#Buttons*82)+14,0,40)
    end
    for i,v in pairs(Buttons) do
        local NewButton = v
        if type(v) == "string" then
            NewButton = Button.new({Text = v, ButtonSize = 0.95}, self.ButtonsFrame)
        else
            NewButton:Move(self.ButtonsFrame, true)
        end
        NewButton.Arguments.Unpausable = true
        NewButton.ButtonFrame.Size = UDim2.new(0,82,1,0)
        NewButton:Clicked(function()
            self:Destroy()
            if self.Action then self.Action(i) end
        end)
    end
    local function syncTextFrame()
        self.TextFrame.Size = UDim2.new(0,self.Textbox.TextBounds.X+24,0,self.Textbox.TextBounds.Y+21)
    end
    syncTextFrame()
    self.Textbox.Changed:Connect(function(p)
        if p == "TextBounds" then
            syncTextFrame()
        end
    end)
    local function syncTextPromptSize()
        self:Reset(self.Arguments.Title, self.TextPromptLayout.AbsoluteContentSize.X, self.TextPromptLayout.AbsoluteContentSize.Y)
        self.TextPromptContainer.Size = UDim2.fromOffset(self.TextPromptLayout.AbsoluteContentSize.X, self.TextPromptLayout.AbsoluteContentSize.Y)
        self.TextPromptContainer.Parent = self.Parent
    end
    syncTextPromptSize()
    self.TextPromptLayout.Changed:Connect(function(p)
        if p == "AbsoluteContentSize" then
            syncTextPromptSize()
        end
    end)
    return self
end

return TextPrompt]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXA491FAB060AB488C9FDCF58C3677C057">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Template</string>
							<string name="ScriptGuid">{b1429da5-9a1e-247d-8592-988699bd7592}</string>
							<ProtectedString name="Source"><![CDATA[-- template for classes

--inheritance
--local GUIElement = require(GV.LibraryDir.GUIElement)
--setmetatable(,GUIElement)

local temp = {}
temp.__index = temp


function temp.new()
    --self = GUIElement.new()
    local self = {}
    setmetatable(self,temp)
    return self
end

return temp]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXB89E045F7475428B86A5EA9B30191D72">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GizmoModule</string>
					<string name="ScriptGuid">{E7C7AECE-74E7-46B0-9465-1ACD07489A1A}</string>
					<ProtectedString name="Source"><![CDATA[--!nocheck

-- CeiveImGizmo
-- https://github.com/JakeyWasTaken/CeiveImGizmo

local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Terrain = workspace:WaitForChild("Terrain")
local TargetParent = workspace:WaitForChild("Terrain") -- Change this if you wish to have gizmos under a different location, e.g CoreGui

assert(Terrain, "No terrain object found under workspace")
assert(TargetParent, "No target parent found.")

local AOTWireframeHandle: WireframeHandleAdornment = TargetParent:FindFirstChild("AOTGizmoAdornment")
local WireframeHandle: WireframeHandleAdornment = TargetParent:FindFirstChild("GizmoAdornment")

if not AOTWireframeHandle then
	AOTWireframeHandle = Instance.new("WireframeHandleAdornment")
	AOTWireframeHandle.Adornee = Terrain
	AOTWireframeHandle.ZIndex = 1
	AOTWireframeHandle.AlwaysOnTop = true
	AOTWireframeHandle.Name = "AOTGizmoAdornment"
	AOTWireframeHandle.Parent = TargetParent
end

if not WireframeHandle then
	WireframeHandle = Instance.new("WireframeHandleAdornment")
	WireframeHandle.Adornee = Terrain
	WireframeHandle.ZIndex = 1
	WireframeHandle.AlwaysOnTop = false
	WireframeHandle.Name = "GizmoAdornment"
	WireframeHandle.Parent = TargetParent
end

local Gizmos = script:WaitForChild("Gizmos")

local ActiveObjects = {}
local RetainObjects = {}
local Debris = {}
local Tweens = {}
local PropertyTable = { AlwaysOnTop = true, Color3 = Color3.fromRGB(13, 105, 172), Transparency = 0 } -- Defaults
local Pool = {}

local CleanerScheduled = false

local function Retain(Gizmo, GizmoProperties)
	table.insert(RetainObjects, { Gizmo, GizmoProperties })
end

local function Register(object)
	object.Parent = TargetParent
	table.insert(ActiveObjects, object)
end

local function Release(object)
	local ClassName = object.ClassName

	if not Pool[ClassName] then
		Pool[ClassName] = {}
	end

	object:Remove()
	table.insert(Pool[ClassName], object)
end

local function Request(ClassName)
	if not Pool[ClassName] then
		return Instance.new(ClassName)
	end

	local Object = table.remove(Pool[ClassName])

	if not Object then
		return Instance.new(ClassName)
	end

	return Object
end

local function Lerp(a, b, t)
	return a + (b - a) * t
end

local function deepCopy(original)
	local copy = {}
	for k, v in pairs(original) do
		if type(v) == "table" then
			v = deepCopy(v)
		end
		copy[k] = v
	end
	return copy
end

-- Types

type IRay = {
	Draw: (self: IRay, Origin: Vector3, End: Vector3) -> (),
	Create: (
		self: IRay,
		Origin: Vector3,
		End: Vector3
	) -> { Origin: Vector3, End: Vector3, Color3: Color3, AlwaysOnTop: boolean, Transparency: number },
}

type IBox = {
	Draw: (self: IBox, Transform: CFrame, Size: Vector3, DrawTriangles: boolean) -> (),
	Create: (
		self: IBox,
		Transform: CFrame,
		Size: Vector3,
		DrawTriangles: boolean
	) -> {
		Transform: CFrame,
		Size: Vector3,
		DrawTriangles: boolean,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IPlane = {
	Draw: (self: IPlane, Position: Vector3, Normal: Vector3, Size: Vector3) -> (),
	Create: (
		self: IPlane,
		Position: Vector3,
		Normal: Vector3,
		Size: Vector3
	) -> {
		Position: Vector3,
		Normal: Vector3,
		Size: Vector3,
		DrawTriangles: boolean,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IWedge = {
	Draw: (self: IWedge, Transform: CFrame, Size: Vector3, DrawTriangles: boolean) -> (),
	Create: (
		self: IWedge,
		Transform: CFrame,
		Size: Vector3,
		DrawTriangles: boolean
	) -> {
		Transform: CFrame,
		Size: Vector3,
		DrawTriangles: boolean,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ICircle = {
	Draw: (self: ICircle, Transform: CFrame, Radius: number, Subdivisions: number, Angle: number, ConnectToStart: boolean?) -> (),
	Create: (
		self: ICircle,
		Transform: CFrame,
		Radius: number,
		Subdivisions: number,
		Angle: number,
		ConnectToStart: boolean?
	) -> {
		Transform: CFrame,
		Radius: number,
		Subdivisions: number,
		ConnectToStart: boolean?,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ISphere = {
	Draw: (self: ISphere, Transform: CFrame, Radius: number, Subdivisions: number, Angle: number) -> (),
	Create: (
		self: ISphere,
		Transform: CFrame,
		Radius: number,
		Subdivisions: number,
		Angle: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Subdivisions: number,
		Angle: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ICylinder = {
	Draw: (self: ICylinder, Transform: CFrame, Radius: number, Length: number, Subdivisions: number) -> (),
	Create: (
		self: ICylinder,
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ICapsule = {
	Draw: (self: ICapsule, Transform: CFrame, Radius: number, Length: number, Subdivisions: number) -> (),
	Create: (
		self: ICapsule,
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ICone = {
	Draw: (self: ICone, Transform: CFrame, Radius: number, Length: number, Subdivisions: number) -> (),
	Create: (
		self: ICone,
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IArrow = {
	Draw: (self: IArrow, Origin: Vector3, End: Vector3, Radius: number, Length: number, Subdivisions: number) -> (),
	Create: (
		self: IArrow,
		Origin: Vector3,
		End: Vector3,
		Radius: number,
		Length: number,
		Subdivisions: number
	) -> {
		Origin: Vector3,
		End: Vector3,
		Radius: number,
		Length: number,
		Subdivisions: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IMesh = {
	Draw: (self: IMesh, Transform: CFrame, Size: Vector3, Vertices: {}, Faces: {}) -> (),
	Create: (
		self: IMesh,
		Transform: CFrame,
		Size: Vector3,
		Vertices: {},
		Faces: {}
	) -> {
		Transform: CFrame,
		Size: Vector3,
		Vertices: {},
		Faces: {},
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type ILine = {
	Draw: (self: ILine, Transform: CFrame, Length: number) -> (),
	Create: (
		self: ILine,
		Transform: CFrame,
		Length: number
	) -> { Transform: CFrame, Length: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean },
}

type IVolumeCone = {
	Draw: (self: IVolumeCone, Transform: CFrame, Radius: number, Length: number) -> (),
	Create: (
		self: IVolumeCone,
		Transform: CFrame,
		Radius: number,
		Length: number
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IVolumeBox = {
	Draw: (self: IVolumeBox, Transform: CFrame, Size: Vector3) -> (),
	Create: (
		self: IVolumeBox,
		Transform: CFrame,
		Size: Vector3
	) -> { Transform: CFrame, Size: Vector3, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean },
}

type IVolumeSphere = {
	Draw: (self: IVolumeSphere, Transform: CFrame, Radius: number) -> (),
	Create: (
		self: IVolumeSphere,
		Transform: CFrame,
		Radius: number
	) -> { Transform: CFrame, Radius: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean },
}

type IVolumeCylinder = {
	Draw: (self: IVolumeCylinder, Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?) -> (),
	Create: (
		self: IVolumeCylinder,
		Transform: CFrame,
		Radius: number,
		Length: number,
		InnerRadius: number?,
		Angle: number?
	) -> {
		Transform: CFrame,
		Radius: number,
		Length: number,
		InnerRadius: number?,
		Angle: number?,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IVolumeArrow = {
	Draw: (self: IVolumeArrow, Origin: Vector3, End: Vector3, CylinderRadius: number, ConeRadius: number, Length: number, UseCylinder: boolean?) -> (),
	Create: (
		self: IVolumeArrow,
		Origin: Vector3,
		End: Vector3,
		CylinderRadius: number,
		ConeRadius: number,
		Length: number,
		UseCylinder: boolean?
	) -> {
		Origin: Vector3,
		End: Vector3,
		CylinderRadius: number,
		ConeRadius: number,
		Length: number,
		UseCylinder: boolean?,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IText = {
	Draw: (self: IText, Origin: Vector3, Text: string, Size: number?) -> (),
	Create: (
		self: IText,
		Origin: Vector3,
		Text: string,
		Size: number?
	) -> {
		Origin: Vector3,
		Text: string,
		Size: number?,
		Color3: Color3,
		AlwaysOnTop: boolean,
		Transparency: number,
		Enabled: boolean,
		Destroy: boolean,
	},
}

type IStyles = {
	Color: string,
	Transparency: number,
	AlwaysOnTop: boolean,
}

type IStyle = "Color3" | "Transparency" | "AlwaysOnTop"

type ICeive = {
	ActiveRays: number,
	ActiveInstances: number,

	PushProperty: (Property: IStyle, Value: any?) -> (),
	PopProperty: (Property: IStyle) -> any?,
	SetStyle: (Color: Color3?, Transparency: number?, AlwaysOnTop: boolean?) -> (),
	AddDebrisInSeconds: (Seconds: number, Callback: () -> ()) -> (),
	AddDebrisInFrames: (Frames: number, Callback: () -> ()) -> (),
	SetEnabled: (Value: boolean) -> (),
	RemoveAdornments: () -> (),
	DoCleaning: () -> (),
	ScheduleCleaning: () -> (),
	TweenProperies: (Properties: {}, Goal: {}, TweenInfo: TweenInfo) -> () -> (),
	Init: () -> (),

	Styles: IStyles,

	Ray: IRay,
	Line: ILine,
	Box: IBox,
	Plane: IPlane,
	Wedge: IWedge,
	Circle: ICircle,
	Sphere: ISphere,
	Cylinder: ICylinder,
	Capsule: ICapsule,
	Cone: ICone,
	Arrow: IArrow,
	Mesh: IMesh,
	Text: IText,
	VolumeCone: IVolumeCone,
	VolumeBox: IVolumeBox,
	VolumeSphere: IVolumeSphere,
	VolumeCylinder: IVolumeCylinder,
	VolumeArrow: IVolumeArrow,
}

-- Ceive

--- @class CEIVE
--- Root class for all the gizmos.

local Styles = {
	Color = "Color3",
	Transparency = "Transparency",
	AlwaysOnTop = "AlwaysOnTop",
}

local Ceive: ICeive = {
	Enabled = true,
	ActiveRays = 0,
	ActiveInstances = 0,

	Styles = Styles,

	AOTWireframeHandle = AOTWireframeHandle,
	WireframeHandle = WireframeHandle,
}

--- @within CEIVE
--- @function GetPoolSize
--- @return number
function Ceive.GetPoolSize(): number
	local n = 0

	for _, t in Pool do
		n += #t
	end

	return n
end

--- @within CEIVE
--- @function PushProperty
--- Push Property sets the value of a property.
--- @param Property string
--- @param Value any
function Ceive.PushProperty(Property, Value)
	PropertyTable[Property] = Value

	if Property == "AlwaysOnTop" then
		return
	end

	pcall(function()
		AOTWireframeHandle[Property] = Value
		WireframeHandle[Property] = Value
	end)
end

--- @within CEIVE
--- @function PopProperty
--- Pop Property returns the property value.
--- @param Property string
--- @return any
function Ceive.PopProperty(Property)
	if PropertyTable[Property] then
		return PropertyTable[Property]
	end

	return AOTWireframeHandle[Property]
end

--- @within CEIVE
--- @function SetStyle
--- Sets the style of all properties.
--- @param Color Color3?
--- @param Transparency number?
--- @param AlwaysOnTop boolean?
function Ceive.SetStyle(Color, Transparency, AlwaysOnTop)
	if Color ~= nil and typeof(Color) == "Color3" then
		Ceive.PushProperty("Color3", Color)
	end

	if Transparency ~= nil and typeof(Transparency) == "number" then
		Ceive.PushProperty("Transparency", Transparency)
	end

	if AlwaysOnTop ~= nil and typeof(AlwaysOnTop) == "boolean" then
		Ceive.PushProperty("AlwaysOnTop", AlwaysOnTop)
	end
end

--- @within CEIVE
--- @function DoCleaning
function Ceive.DoCleaning()
	AOTWireframeHandle:Clear()
	WireframeHandle:Clear()

	for _, Object in ActiveObjects do
		Release(Object)
	end

	ActiveObjects = {}

	Ceive.ActiveRays = 0
	Ceive.ActiveInstances = 0
end

--- @within CEIVE
--- @function ScheduleCleaning
function Ceive.ScheduleCleaning()
	if CleanerScheduled then
		return
	end

	CleanerScheduled = true

	task.delay(0, function()
		Ceive.DoCleaning()

		CleanerScheduled = false
	end)
end

--- @within CEIVE
--- @function AddDebrisInSeconds
--- Acts as a wrapper for your code that runs for a provided amount of seconds.
--- @param Seconds number
--- @param Callback function
function Ceive.AddDebrisInSeconds(Seconds: number, Callback)
	table.insert(Debris, { "Seconds", Seconds, os.clock(), Callback })
end

--- @within CEIVE
--- @function AddDebrisInFrames
--- Acts as a wrapper for your code that runs for a provided amount of frames.
--- @param Frames number
--- @param Callback function
function Ceive.AddDebrisInFrames(Frames: number, Callback)
	table.insert(Debris, { "Frames", Frames, 0, Callback })
end

--- @within CEIVE
--- @function TweenProperties
--- Tweens the property table to the goal with the provided TweenInfo, returns a function which can be used to cancel.
--- @param Properties table
--- @param Goal table
--- @param TweenInfo TweenInfo
--- @return CancelFunction
function Ceive.TweenProperties(Properties: {}, Goal: {}, TweenInfo: TweenInfo): () -> ()
	local p_Properties = Properties
	local c_Properties = deepCopy(Properties)

	local Tween = {
		p_Properties = p_Properties,
		Properties = c_Properties,
		Goal = Goal,
		TweenInfo = TweenInfo,
		Time = 0,
	}

	Tweens[Tween] = true

	return function()
		Tweens[Tween] = nil
	end
end

--- @within CEIVE
--- @function Init
function Ceive.Init()
	RunService.RenderStepped:Connect(function(dt)
    	if Ceive.Enabled then
			-- Add our gizmos if they were removed for whatever reasons
			if not TargetParent:FindFirstChild("AOTGizmoAdornment") then
				AOTWireframeHandle = Instance.new("WireframeHandleAdornment")
				AOTWireframeHandle.Adornee = Terrain
				AOTWireframeHandle.ZIndex = 1
				AOTWireframeHandle.AlwaysOnTop = true
				AOTWireframeHandle.Name = "AOTGizmoAdornment"
				AOTWireframeHandle.Parent = TargetParent

				Ceive.AOTWireframeHandle = AOTWireframeHandle
			end

			if not TargetParent:FindFirstChild("GizmoAdornment") then
				WireframeHandle = Instance.new("WireframeHandleAdornment")
				WireframeHandle.Adornee = Terrain
				WireframeHandle.ZIndex = 1
				WireframeHandle.AlwaysOnTop = false
				WireframeHandle.Name = "GizmoAdornment"
				WireframeHandle.Parent = TargetParent

				Ceive.WireframeHandle = WireframeHandle
			end
		end

		for Tween in Tweens do
			Tween.Time += dt
			local Alpha = Tween.Time / Tween.TweenInfo.Time

			if Alpha > 1 then
				Alpha = 1
			end

			local function LerpProperty(Start, End, Time)
				if type(Start) == "number" then
					return Lerp(Start, End, Time)
				end

				return Start:Lerp(End, Time)
			end

			for k, v in Tween.Properties do
				if not Tween.Goal[k] then
					continue
				end

				local TweenAlpha = TweenService:GetValue(Alpha, Tween.TweenInfo.EasingStyle, Tween.TweenInfo.EasingDirection)
				local PropertyValue = LerpProperty(v, Tween.Goal[k], TweenAlpha)

				Tween.p_Properties[k] = PropertyValue
			end

			if Alpha == 1 then
				Tweens[Tween] = nil
			end
		end

		for i = #Debris, 1, -1 do
			local DebrisObject = Debris[i]
			local DebrisType = DebrisObject[1]
			local DebrisLifetime = DebrisObject[2]
			local DebrisBirth = DebrisObject[3]
			local DebrisCallback = DebrisObject[4]

			if DebrisType == "Seconds" then
				if os.clock() - DebrisBirth > DebrisLifetime then
					table.remove(Debris, i)
					continue
				end

				DebrisCallback()

				continue
			end

			if DebrisBirth > DebrisLifetime then
				table.remove(Debris, i)
				continue
			end

			DebrisObject[2] += 1 -- Add 1 frame to the counter

			DebrisCallback()
		end

		for i = #RetainObjects, 1, -1 do
			local Gizmo = RetainObjects[i]
			local GizmoPropertys = Gizmo[2]

			if not GizmoPropertys.Enabled then
				continue
			end

			if GizmoPropertys.Destroy then
				table.remove(RetainObjects, i)
			end

			Gizmo[1]:Update(GizmoPropertys)
		end
	end)
end

--- @within CEIVE
--- @function SetEnabled
--- @param Value boolean
function Ceive.SetEnabled(Value)
	Ceive.Enabled = Value

	if Value == false then
		Ceive.DoCleaning()
	end
end

--- @within CEIVE
--- @function RemoveAdornments
--- Removes adornments, will be added back next frame if Ceive is enabled
function Ceive.RemoveAdornments()
	if TargetParent:FindFirstChild("AOTGizmoAdornment") then
		TargetParent:FindFirstChild("AOTGizmoAdornment"):Destroy()
	end

	if TargetParent:FindFirstChild("GizmoAdornment") then
		TargetParent:FindFirstChild("GizmoAdornment"):Destroy()
	end
end

-- Load Gizmos

for _, Gizmo in Gizmos:GetChildren() do
	Ceive[Gizmo.Name] = require(Gizmo).Init(Ceive, PropertyTable, Request, Release, Retain, Register)
end

return Ceive
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBX5FA6775FDBDC4076B4BBCE1728184F19">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Gizmos</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX065E1CE790964C7DAD0D693A41A97D4E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Arrow</string>
							<string name="ScriptGuid">{FE4A26B8-189F-46A2-86AD-C5DF02237559}</string>
							<ProtectedString name="Source"><![CDATA[--- @class Arrow
--- Renders a wireframe arrow.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end


--- @within Arrow
--- @function Draw
--- @param Origin Vector3
--- @param End Vector3
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
function Gizmo:Draw(Origin: Vector3, End: Vector3, Radius: number, Length: number, Subdivisions: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	Ceive.Ray:Draw(Origin, End)

	local ArrowCFrame = CFrame.lookAt(End + ((Origin - End).Unit * (Length / 2)), End)
	Ceive.Cone:Draw(ArrowCFrame, Radius, Length, Subdivisions)
end

--- @within Arrow
--- @function Create
--- @param Origin Vector3
--- @param End Vector3
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
--- @return {Origin: Vector3, End: Vector3, Radius: number, Length: number, Subdivisions: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Origin: Vector3, End: Vector3, Radius: number, Length: number, Subdivisions: number)
	local PropertyTable = {
		Origin = Origin,
		End = End,
		Radius = Radius,
		Length = Length,
		Subdivisions = Subdivisions,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Origin, PropertyTable.End, PropertyTable.Radius, PropertyTable.Length, PropertyTable.Subdivisions)
end

return Gizmo
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF7035146F33246C3B735E69B3F4E4064">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Box</string>
							<string name="ScriptGuid">{09A16F69-DBC6-485B-A143-8377799A3305}</string>
							<ProtectedString name="Source"><![CDATA[--- @class Box
--- Renders a wireframe box.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Box
--- @function Draw
--- @param Transform CFrame
--- @param Size Vector3
--- @param DrawTriangles boolean
function Gizmo:Draw(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Position = Transform.Position
	local Uv = Transform.UpVector
	local Rv = Transform.RightVector
	local Lv = Transform.LookVector
	local sO2 = Size / 2
	local sUv = Uv * sO2.Y
	local sRv = Rv * sO2.X
	local sLv = Lv * sO2.Z

	local function CalculateYFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (lUv - lRv - lLv)
		local BottomRight = Position + (lUv + lRv - lLv)

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	local function CalculateZFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv + lLv)
		local BottomRight = Position + (-lUv + lRv + lLv)

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	local function CalculateXFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv - lLv)
		local TopRight = Position + (lUv - lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv - lLv)
		local BottomRight = Position + (-lUv - lRv + lLv)

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	CalculateXFace(sUv, sRv, sLv)
	CalculateXFace(sUv, -sRv, sLv)

	CalculateYFace(sUv, sRv, sLv)
	CalculateYFace(-sUv, sRv, sLv)

	CalculateZFace(sUv, sRv, sLv)
	CalculateZFace(sUv, sRv, -sLv)
end

--- @within Box
--- @function Create
--- @param Transform CFrame
--- @param Size Vector3
--- @param DrawTriangles boolean
--- @return {Transform: CFrame, Size: Vector3, DrawTriangles: boolean, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		DrawTriangles = DrawTriangles,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size, PropertyTable.DrawTriangles)
end

return Gizmo]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXADEDE21A45634B6CAB0683E879E4C462">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Capsule</string>
							<string name="ScriptGuid">{82AA1C67-3E26-41E3-BE6D-1B22F07187B7}</string>
							<ProtectedString name="Source"><![CDATA[local Rad180D = math.rad(180)

--- @class Capsule
--- Renders a wireframe capsule.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Capsule
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	-- Draw top and bottom of cylinder
	local TopOfCylinder = Transform.Position + (Transform.UpVector * (Length / 2))
	local BottomOfCylinder = Transform.Position - (Transform.UpVector * (Length / 2))

	TopOfCylinder = CFrame.lookAt(TopOfCylinder, TopOfCylinder + Transform.UpVector)
	BottomOfCylinder = CFrame.lookAt(BottomOfCylinder, BottomOfCylinder - Transform.UpVector)

	-- Draw Cylinder Lines

	local AnglePerChunk = math.floor(360 / Subdivisions)

	local LastTop
	local LastBottom

	local FirstTop
	local FirstBottom

	for i = 0, 360, AnglePerChunk do
		local XMagnitude = math.sin(math.rad(i)) * Radius
		local YMagnitude = math.cos(math.rad(i)) * Radius

		local VertexOffset = (Transform.LookVector * YMagnitude) + (Transform.RightVector * XMagnitude)
		local TopVertexPosition = TopOfCylinder.Position + VertexOffset
		local BottomVertexPosition = BottomOfCylinder.Position + VertexOffset

		Ceive.Ray:Draw(TopVertexPosition, BottomVertexPosition)

		Ceive.Circle:Draw(CFrame.new(TopOfCylinder.Position) * Transform.Rotation * CFrame.Angles(0, math.rad(i), 0), Radius, Subdivisions / 2, 90, false)
		Ceive.Circle:Draw(CFrame.new(BottomOfCylinder.Position) * Transform.Rotation * CFrame.Angles(Rad180D, math.rad(i), 0), Radius, Subdivisions / 2, 90, false)

		if not LastTop then
			LastTop = TopVertexPosition
			LastBottom = BottomVertexPosition

			FirstTop = TopVertexPosition
			FirstBottom = BottomVertexPosition

			continue
		end

		Ceive.Ray:Draw(LastTop, TopVertexPosition)
		Ceive.Ray:Draw(LastBottom, BottomVertexPosition)

		LastTop = TopVertexPosition
		LastBottom = BottomVertexPosition
	end

	Ceive.Ray:Draw(LastTop, FirstTop)
	Ceive.Ray:Draw(LastBottom, FirstBottom)
end

--- @within Capsule
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
--- @return {Transform: CFrame, Radius: number, Length: number, Subdivisions: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		Subdivisions = Subdivisions,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length, PropertyTable.Subdivisions)
end

return Gizmo]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE80B69091A964E7494C1A5035601DB98">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Circle</string>
							<string name="ScriptGuid">{2ED1E501-5CFC-419C-9405-80392D319B02}</string>
							<ProtectedString name="Source"><![CDATA[--- @class Circle
--- Renders a wireframe Circle.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Circle
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Subdivisions number
--- @param Angle number
--- @param ConnectToStart boolean?
function Gizmo:Draw(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number, ConnectToStart: boolean?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local AnglePerChunk = math.floor(Angle / Subdivisions)

	local PreviousVertex = nil
	local FirstVertex = nil

	local FinishingAngle = 0

	for i = 0, Angle, AnglePerChunk do
		local XMagnitude = math.sin(math.rad(i)) * Radius
		local YMagnitude = math.cos(math.rad(i)) * Radius

		local VertexPosition = Transform.Position + ((Transform.UpVector * YMagnitude) + (Transform.RightVector * XMagnitude))

		if PreviousVertex == nil then
			PreviousVertex = VertexPosition
			FirstVertex = VertexPosition
			FinishingAngle = i
			continue
		end

		Ceive.Ray:Draw(PreviousVertex, VertexPosition)
		PreviousVertex = VertexPosition
		FinishingAngle = i
	end

	if FinishingAngle ~= Angle then
		local XMagnitude = math.sin(math.rad(Angle)) * Radius
		local YMagnitude = math.cos(math.rad(Angle)) * Radius

		local VertexPosition = Transform.Position + ((Transform.UpVector * YMagnitude) + (Transform.RightVector * XMagnitude))

		Ceive.Ray:Draw(PreviousVertex, VertexPosition)
	end

	if ConnectToStart ~= false then
		Ceive.Ray:Draw(PreviousVertex, FirstVertex)
	end

	return PreviousVertex
end

--- @within Circle
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Subdivisions number
--- @param Angle number
--- @param ConnectToStart boolean?
--- @return {Transform: CFrame, Radius: number, Subdivisions: number, Angle: number, ConnectToStart: boolean?, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number, ConnectToStart: boolean?)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Subdivisions = Subdivisions,
		Angle = Angle,
		ConnectToStart = ConnectToStart,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Subdivisions, PropertyTable.Angle, PropertyTable.ConnectToStart)
end

return Gizmo]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX8F6AF378C1D94917B796D85F2765F1BC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Cone</string>
							<string name="ScriptGuid">{7EFB8882-E6E1-4F5B-ABB8-BE64F74B1FC6}</string>
							<ProtectedString name="Source"><![CDATA[local Rad90D = math.rad(90)

--- @class Cone
--- Renders a wireframe cone.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Cone
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	Transform *= CFrame.Angles(-Rad90D, 0, 0)

	local TopOfCone = Transform.Position + Transform.UpVector * (Length / 2)
	local BottomOfCone = Transform.Position + -Transform.UpVector * (Length / 2)

	TopOfCone = CFrame.lookAt(TopOfCone, TopOfCone + Transform.UpVector)
	BottomOfCone = CFrame.lookAt(BottomOfCone, BottomOfCone - Transform.UpVector)

	local AnglePerChunk = math.floor(360 / Subdivisions)

	local Last
	local First

	for i = 0, 360, AnglePerChunk do
		local XMagnitude = math.sin(math.rad(i)) * Radius
		local YMagnitude = math.cos(math.rad(i)) * Radius

		local VertexOffset = (Transform.LookVector * YMagnitude) + (Transform.RightVector * XMagnitude)
		local VertexPosition = BottomOfCone.Position + VertexOffset

		if not Last then
			Last = VertexPosition
			First = VertexPosition

			Ceive.Ray:Draw(VertexPosition, TopOfCone.Position)

			continue
		end

		Ceive.Ray:Draw(VertexPosition, TopOfCone.Position)
		Ceive.Ray:Draw(Last, VertexPosition)

		Last = VertexPosition
	end

	Ceive.Ray:Draw(Last, First)
end

--- @within Cone
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
--- @return {Transform: CFrame, Radius: number, Length: number, Subdivisions: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		Subdivisions = Subdivisions,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length, PropertyTable.Subdivisions)
end

return Gizmo]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX65A78609DD6843AEA59B1BE42BDB80A5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Cylinder</string>
							<string name="ScriptGuid">{18CC67E9-525B-4947-924F-22A80E373871}</string>
							<ProtectedString name="Source"><![CDATA[--- @class Cylinder
--- Renders a wireframe cylinder.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Cylinder
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	-- Draw top and bottom of cylinder
	local TopOfCylinder = Transform.Position + (Transform.UpVector * (Length / 2))
	local BottomOfCylinder = Transform.Position - (Transform.UpVector * (Length / 2))

	TopOfCylinder = CFrame.lookAt(TopOfCylinder, TopOfCylinder + Transform.UpVector)
	BottomOfCylinder = CFrame.lookAt(BottomOfCylinder, BottomOfCylinder - Transform.UpVector)

	-- Draw Cylinder Lines

	local AnglePerChunk = math.floor(360 / Subdivisions)

	local LastTop
	local LastBottom

	local FirstTop
	local FirstBottom

	for i = 0, 360, AnglePerChunk do
		local XMagnitude = math.sin(math.rad(i)) * Radius
		local YMagnitude = math.cos(math.rad(i)) * Radius

		local VertexOffset = (Transform.LookVector * YMagnitude) + (Transform.RightVector * XMagnitude)
		local TopVertexPosition = TopOfCylinder.Position + VertexOffset
		local BottomVertexPosition = BottomOfCylinder.Position + VertexOffset

		Ceive.Ray:Draw(TopVertexPosition, BottomVertexPosition)

		if not LastTop then
			LastTop = TopVertexPosition
			LastBottom = BottomVertexPosition

			FirstTop = TopVertexPosition
			FirstBottom = BottomVertexPosition

			continue
		end

		Ceive.Ray:Draw(LastTop, TopVertexPosition)
		Ceive.Ray:Draw(LastBottom, BottomVertexPosition)

		LastTop = TopVertexPosition
		LastBottom = BottomVertexPosition
	end

	Ceive.Ray:Draw(LastTop, FirstTop)
	Ceive.Ray:Draw(LastBottom, FirstBottom)
end

--- @within Cylinder
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param Subdivisions number
--- @return {Transform: CFrame, Radius: number, Length: number, Subdivisions: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, Subdivisions: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		Subdivisions = Subdivisions,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length, PropertyTable.Subdivisions)
end

return Gizmo]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXAC4D16B03ECE49339052AD9DC90F88E1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Mesh</string>
							<string name="ScriptGuid">{97B41F42-D848-463E-AABB-CF14ACD166CF}</string>
							<ProtectedString name="Source"><![CDATA[local function Map(n, start, stop, newStart, newStop)
	return ((n - start) / (stop - start)) * (newStop - newStart) + newStart
end

--- @class Mesh
--- Renders a wireframe mesh.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Mesh
--- @function Draw
--- @param Transform CFrame
--- @param Size Vector3
--- @param Vertices table
--- @param Faces table
function Gizmo:Draw(Transform: CFrame, Size: Vector3, Vertices, Faces)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local maxX = -math.huge
	local maxY = -math.huge
	local maxZ = -math.huge

	local minX = math.huge
	local minY = math.huge
	local minZ = math.huge

	for _, vertex in Vertices do
		maxX = math.max(maxX, vertex.x)
		maxY = math.max(maxY, vertex.y)
		maxZ = math.max(maxZ, vertex.z)

		minX = math.min(minX, vertex.x)
		minY = math.min(minY, vertex.y)
		minZ = math.min(minZ, vertex.z)
	end

	for i, vertex in Vertices do
		local vX = Map(vertex.x, minX, maxX, -0.5, 0.5)
		local vY = Map(vertex.y, minY, maxY, -0.5, 0.5)
		local vZ = Map(vertex.z, minZ, maxZ, -0.5, 0.5)

		local vertexCFrame = Transform * CFrame.new(Vector3.new(vX, vY, vZ) * Size)
		Vertices[i] = vertexCFrame
	end

	for _, face in Faces do
		if #face == 3 then
			local vCF1 = Vertices[face[1].v]
			local vCF2 = Vertices[face[2].v]
			local vCF3 = Vertices[face[3].v]

			Ceive.Ray:Draw(vCF1.Position, vCF2.Position)
			Ceive.Ray:Draw(vCF2.Position, vCF3.Position)
			Ceive.Ray:Draw(vCF3.Position, vCF1.Position)
		else
			local vCF1 = Vertices[face[1].v]
			local vCF2 = Vertices[face[2].v]
			local vCF3 = Vertices[face[3].v]
			local vCF4 = Vertices[face[4].v]

			Ceive.Ray:Draw(vCF1.Position, vCF2.Position)
			Ceive.Ray:Draw(vCF1.Position, vCF4.Position)
			Ceive.Ray:Draw(vCF4.Position, vCF2.Position)

			Ceive.Ray:Draw(vCF3.Position, vCF4.Position)
			Ceive.Ray:Draw(vCF2.Position, vCF3.Position)
		end
	end
end

--- @within Mesh
--- @function Create
--- @param Transform CFrame
--- @param Size Vector3
--- @param Vertices table
--- @param Faces table
--- @return {Transform: CFrame, Size: Vector3, Vertices: {}, Faces: {}, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Size: Vector3, Vertices, Faces)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		Vertices = Vertices,
		Faces = Faces,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size, PropertyTable.Vertices, PropertyTable.Faces)
end

return Gizmo]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA06958FA52A14A18B8E25D2EE2DE703A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Ray</string>
							<string name="ScriptGuid">{564D53D3-4A83-4D23-96FD-DE967C6D28DF}</string>
							<ProtectedString name="Source"><![CDATA[--- @class Ray
--- Renders a line between two points.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)
	
	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	
	return self
end

--- @within Ray
--- @function Draw
--- @param Origin Vector3
--- @param End Vector3
function Gizmo:Draw(Origin: Vector3, End: Vector3)
	local Ceive = self.Ceive
	
	if not Ceive.Enabled then
		return
	end
	
	if self.Propertys.AlwaysOnTop then
		Ceive.AOTWireframeHandle:AddLine(Origin, End)
	else
		Ceive.WireframeHandle:AddLine(Origin, End)
	end
	
	self.Ceive.ActiveRays += 1
	
	self.Ceive.ScheduleCleaning()
end

--- @within Ray
--- @function Create
--- @param Origin Vector3
--- @param End Vector3
--- @return {Origin: Vector3, End: Vector3, Color3: Color3, AlwaysOnTop: boolean, Transparency: number}
function Gizmo:Create(Origin: Vector3, End: Vector3)
	local PropertyTable = {
		Origin = Origin,
		End = End,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}
	
	self.Retain(self, PropertyTable)
	
	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive
	
	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)
	
	self:Draw(PropertyTable.Origin, PropertyTable.End)
end

return Gizmo]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB01757CD7C5D4C3A998A9B5BF6E79E7F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Sphere</string>
							<string name="ScriptGuid">{EF579BA9-6BFB-4565-884B-1FD7F024C728}</string>
							<ProtectedString name="Source"><![CDATA[local Rad90D = math.rad(90)

--- @class Sphere
--- Renders a wireframe sphere.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Sphere
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Subdivisions number
--- @param Angle number
function Gizmo:Draw(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	Ceive.Circle:Draw(Transform, Radius, Subdivisions, Angle)
	Ceive.Circle:Draw(Transform * CFrame.Angles(0, Rad90D, 0), Radius, Subdivisions, Angle)
	Ceive.Circle:Draw(Transform * CFrame.Angles(Rad90D, 0, 0), Radius, Subdivisions, Angle)
end

--- @within Sphere
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Subdivisions number
--- @param Angle number
--- @return {Transform: CFrame, Radius: number, Subdivisions: number, Angle: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Subdivisions: number, Angle: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Subdivisions = Subdivisions,
		Angle = Angle,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Subdivisions, PropertyTable.Angle)
end

return Gizmo]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1AE1F8C5F9C54C6A84B6C766BA4CAC1C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VolumeArrow</string>
							<string name="ScriptGuid">{A3463BC7-376A-4DA3-A5EF-03FA24AC6BF4}</string>
							<ProtectedString name="Source"><![CDATA[--- @class VolumeArrow
--- Renders an arrow with a ConeHandleAdornment instead of a wireframe cone.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

--- @within VolumeArrow
--- @function Draw
--- @param Origin Vector3
--- @param End Vector3
--- @param CylinderRadius number
--- @param ConeRadius number
--- @param Length number
--- @param UseCylinder boolean?
function Gizmo:Draw(Origin: Vector3, End: Vector3, CylinderRadius: number, ConeRadius: number, Length: number, UseCylinder: boolean?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local ArrowCFrame = CFrame.lookAt(End - (End - Origin).Unit * (Length / 2), End)

	if UseCylinder == true then
		local BottomCone = ArrowCFrame.Position
		local CylinderLength = (BottomCone - Origin).Magnitude
		local CylinderCFrame = CFrame.lookAt( (Origin + BottomCone) / 2, End )

		Ceive.VolumeCylinder:Draw(CylinderCFrame, CylinderRadius, CylinderLength)
	else
		Ceive.Ray:Draw(Origin, End)
	end

	Ceive.VolumeCone:Draw(ArrowCFrame, ConeRadius, Length)
	self.Ceive.ScheduleCleaning()
end

--- @within VolumeArrow
--- @function Create
--- @param Origin Vector3
--- @param End Vector3
--- @param CylinderRadius number
--- @param ConeRadius number
--- @param Length number
--- @param UseCylinder boolean?
--- @return {Origin: Vector3, End: Vector3, CylinderRadius: number, ConeRadius: number, Length: number,  UseCylinder: boolean?, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Origin: Vector3, End: Vector3, CylinderRadius: number, ConeRadius: number, Length: number, UseCylinder: boolean?)
	local PropertyTable = {
		Origin = Origin,
		End = End,
		CylinderRadius = CylinderRadius,
		ConeRadius = ConeRadius,
		Length = Length,
		UseCylinder = UseCylinder,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Origin, PropertyTable.End, PropertyTable.Radius, PropertyTable.Length, PropertyTable.UseCylinder)
end

return Gizmo
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX36CC8E7846E74D288BDCA6A1BE39C1E0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VolumeBox</string>
							<string name="ScriptGuid">{7D39D01F-CE02-4CC7-85E1-40118C6AF946}</string>
							<ProtectedString name="Source"><![CDATA[local Terrain = workspace.Terrain

--- @class VolumeBox
--- Renders a BoxHandleAdornment.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

--- @within VolumeBox
--- @function Draw
--- @param Transform CFrame
--- @param Size Vector3
function Gizmo:Draw(Transform: CFrame, Size: Vector3)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Box = self.Request("BoxHandleAdornment")
	Box.Color3 = self.Propertys.Color3
	Box.Transparency = self.Propertys.Transparency

	Box.CFrame = Transform
	Box.Size = Size
	Box.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Box.ZIndex = 1
	Box.Adornee = Terrain
	Box.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Box)
	self.Ceive.ScheduleCleaning()
end

--- @within VolumeBox
--- @function Create
--- @param Transform CFrame
--- @param Size Vector3
--- @return {Transform: CFrame, Size: Vector3, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Size: Vector3)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size)
end

return Gizmo
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7619C55E1A5445139F48ACA1402DD43B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VolumeCone</string>
							<string name="ScriptGuid">{561E77C7-EE4D-4A6C-8FD4-80B1C4C9AAAE}</string>
							<ProtectedString name="Source"><![CDATA[local Terrain = workspace.Terrain

--- @class VolumeCone
--- Renders a ConeHandleAdornment.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

--- @within VolumeCone
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Cone = self.Request("ConeHandleAdornment")
	Cone.Color3 = self.Propertys.Color3
	Cone.Transparency = self.Propertys.Transparency

	Cone.CFrame = Transform
	Cone.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Cone.ZIndex = 1
	Cone.Height = Length
	Cone.Radius = Radius
	Cone.Adornee = Terrain
	Cone.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Cone)
	self.Ceive.ScheduleCleaning()
end

--- @within VolumeCone
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @return {Transform: CFrame, Radius: number, Length: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Length: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length)
end

return Gizmo
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX81A38AF4D063458F8E6A209CA2A4D5AB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VolumeCylinder</string>
							<string name="ScriptGuid">{30AEC92B-16D5-4A6E-BEBC-632AD50E681E}</string>
							<ProtectedString name="Source"><![CDATA[local Terrain = workspace.Terrain

--- @class VolumeCylinder
--- Renders a CylinderHandleAdornment.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

--- @within VolumeCylinder
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param InnerRadius number?
--- @param Angle number?
function Gizmo:Draw(Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Cylinder = self.Request("CylinderHandleAdornment")
	Cylinder.Color3 = self.Propertys.Color3
	Cylinder.Transparency = self.Propertys.Transparency

	Cylinder.CFrame = Transform
	Cylinder.Height = Length
	Cylinder.Radius = Radius
	Cylinder.InnerRadius = InnerRadius or 0
	Cylinder.Angle = Angle or 360
	Cylinder.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Cylinder.ZIndex = 1
	Cylinder.Adornee = Terrain
	Cylinder.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Cylinder)
	self.Ceive.ScheduleCleaning()
end

--- @within VolumeCylinder
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @param Length number
--- @param InnerRadius number?
--- @param Angle number?
--- @return {Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number, Length: number, InnerRadius: number?, Angle: number?)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		Length = Length,
		InnerRadius = InnerRadius or 0,
		Angle = Angle or 360,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius, PropertyTable.Length, PropertyTable.InnerRadius, PropertyTable.Angle)
end

return Gizmo
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX371BBE2FC0084B988142B79376BA29D7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VolumeSphere</string>
							<string name="ScriptGuid">{6EF029F5-A8AA-4505-9CBC-74627DF846C4}</string>
							<ProtectedString name="Source"><![CDATA[local Terrain = workspace.Terrain

--- @class VolumeSphere
--- Renders a SphereHandleAdornment.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain, Register)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain
	self.Register = Register

	return self
end

--- @within VolumeSphere
--- @function Draw
--- @param Transform CFrame
--- @param Radius number
function Gizmo:Draw(Transform: CFrame, Radius: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Sphere = self.Request("SphereHandleAdornment")
	Sphere.Color3 = self.Propertys.Color3
	Sphere.Transparency = self.Propertys.Transparency

	Sphere.CFrame = Transform
	Sphere.Radius = Radius
	Sphere.AlwaysOnTop = self.Propertys.AlwaysOnTop
	Sphere.ZIndex = 1
	Sphere.Adornee = Terrain
	Sphere.Parent = Terrain

	Ceive.ActiveInstances += 1

	self.Register(Sphere)
	self.Ceive.ScheduleCleaning()
end

--- @within VolumeSphere
--- @function Create
--- @param Transform CFrame
--- @param Radius number
--- @return {Transform: CFrame, Radius: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Radius: number)
	local PropertyTable = {
		Transform = Transform,
		Radius = Radius,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Radius)
end

return Gizmo
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE5EB3B975C3A48C1B8CE8D6CB1676D3E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Wedge</string>
							<string name="ScriptGuid">{A5D1EB71-6438-40B4-94A5-0A3963561898}</string>
							<ProtectedString name="Source"><![CDATA[--- @class Wedge
--- Renders a wireframe wedge.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Wedge
--- @function Draw
--- @param Transform CFrame
--- @param Size Vector3
--- @param DrawTriangles boolean?
function Gizmo:Draw(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Position = Transform.Position
	local Uv = Transform.UpVector
	local Rv = Transform.RightVector
	local Lv = Transform.LookVector
	local sO2 = Size / 2
	local sUv = Uv * sO2.Y
	local sRv = Rv * sO2.X
	local sLv = Lv * sO2.Z

	local YTopLeft
	local YTopRight

	local ZBottomLeft
	local ZBottomRight

	local function CalculateYFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (lUv - lRv - lLv)
		local BottomRight = Position + (lUv + lRv - lLv)

		YTopLeft = TopLeft
		YTopRight = TopRight

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	local function CalculateZFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv + lLv)
		local BottomRight = Position + (-lUv + lRv + lLv)

		ZBottomLeft = TopLeft
		ZBottomRight = TopRight

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		if DrawTriangles ~= false then
			Ceive.Ray:Draw(TopRight, BottomLeft)
		end

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	CalculateYFace(-sUv, sRv, sLv)

	CalculateZFace(sUv, sRv, -sLv)

	Ceive.Ray:Draw(YTopLeft, ZBottomLeft)
	Ceive.Ray:Draw(YTopRight, ZBottomRight)
	if DrawTriangles ~= false then
		Ceive.Ray:Draw(YTopRight, ZBottomLeft)
	end
end

--- @within Wedge
--- @function Create
--- @param Transform CFrame
--- @param Size Vector3
--- @param DrawTriangles boolean?
--- @return {Transform: CFrame, Size: Vector3, DrawTriangles: boolean, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Transform: CFrame, Size: Vector3, DrawTriangles: boolean)
	local PropertyTable = {
		Transform = Transform,
		Size = Size,
		DrawTriangles = DrawTriangles,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Size, PropertyTable.DrawTriangles)
end

return Gizmo]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX44FCFF080B8F44B4B5B9BCB5FC66F92D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Line</string>
							<string name="ScriptGuid">{9B72050C-C845-4D2E-816B-95525565A27F}</string>
							<ProtectedString name="Source"><![CDATA[--- @class Line
--- Renders a line at a given CFrame.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Line
--- @function Draw
--- @param Transform CFrame
--- @param Length number
function Gizmo:Draw(Transform: CFrame, Length: number)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	local Origin = Transform.Position + (Transform.LookVector * (-Length / 2))
    local End = Transform.Position + (Transform.LookVector * (Length / 2))

    Ceive.Ray:Draw(Origin, End)
end

--- @within Line
--- @function Create
--- @param Transform CFrame
--- @param Length number
--- @return {Transform: CFrame, Length: number, Color3: Color3, AlwaysOnTop: boolean, Transparency: number}
function Gizmo:Create(Transform: CFrame, Length: number)
	local PropertyTable = {
		Transform = Transform,
		Length = Length,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Transform, PropertyTable.Length)
end

return Gizmo
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX45A08B87AD744BFBAD1FDFEE452910B7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Plane</string>
							<string name="ScriptGuid">{1DFC08AE-096F-4261-8BF1-83D91611B76D}</string>
							<ProtectedString name="Source"><![CDATA[--- @class Plane
--- Renders a wireframe plane.
local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

--- @within Plane
--- @function Draw
--- @param Position Vector3
--- @param Normal Vector3
--- @param Size Vector3
function Gizmo:Draw(Position: Vector3, Normal: Vector3, Size: Vector3)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

    Size *= Vector3.new(1, 1, 0)

    local Transform = CFrame.lookAt(Position, Position + Normal)

	local Uv = Transform.UpVector
	local Rv = Transform.RightVector
	local Lv = Transform.LookVector
	local sO2 = Size / 2
	local sUv = Uv * sO2.Y
	local sRv = Rv * sO2.X
	local sLv = Lv * sO2.Z

	local function CalculateZFace(lUv, lRv, lLv)
		local TopLeft = Position + (lUv - lRv + lLv)
		local TopRight = Position + (lUv + lRv + lLv)
		local BottomLeft = Position + (-lUv - lRv + lLv)
		local BottomRight = Position + (-lUv + lRv + lLv)

		Ceive.Ray:Draw(TopLeft, TopRight)
		Ceive.Ray:Draw(TopLeft, BottomLeft)

		Ceive.Ray:Draw(TopRight, BottomRight)
		Ceive.Ray:Draw(TopRight, BottomLeft)

		Ceive.Ray:Draw(BottomLeft, BottomRight)
	end

	CalculateZFace(sUv, sRv, sLv)
end

--- @within Plane
--- @function Create
--- @param Position Vector3
--- @param Normal Vector3
--- @param Size Vector3
--- @return {Position: Vector3, Normal: Vector3, Size: Vector3, DrawTriangles: boolean, Color3: Color3, AlwaysOnTop: boolean, Transparency: number, Enabled: boolean, Destroy: boolean}
function Gizmo:Create(Position: Vector3, Normal: Vector3, Size: Vector3)
	local PropertyTable = {
		Position = Position,
		Normal = Normal,
        Size = Size,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Position, PropertyTable.Normal, PropertyTable.Size)
end

return Gizmo]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD9B910314B114AEF9F8D036AACEC9C62">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Text</string>
							<string name="ScriptGuid">{648DFE84-6551-4987-BF5C-DF4C5F1AD901}</string>
							<ProtectedString name="Source"><![CDATA[local DROP_SHADOW = true
local OFFSET_PERCENTAGE = 0.00175

local Camera = workspace.CurrentCamera

local Gizmo = {}
Gizmo.__index = Gizmo

function Gizmo.Init(Ceive, Propertys, Request, Release, Retain)
	local self = setmetatable({}, Gizmo)

	self.Ceive = Ceive
	self.Propertys = Propertys
	self.Request = Request
	self.Release = Release
	self.Retain = Retain

	return self
end

function Gizmo:Draw(Origin: Vector3, Text: string, Size: number?)
	local Ceive = self.Ceive

	if not Ceive.Enabled then
		return
	end

	if self.Propertys.AlwaysOnTop then
		if DROP_SHADOW then
			local DistanceToCamera = (Origin - Camera.CFrame.Position).Magnitude
			local PrevColor = Ceive.PopProperty("Color3")

			Ceive.PushProperty("Color3", Color3.new())
			local Offset = -(Vector3.xAxis + Vector3.yAxis).Unit
			Ceive.AOTWireframeHandle:AddText(Origin + Offset * (DistanceToCamera * OFFSET_PERCENTAGE), Text, Size)
			Ceive.PushProperty("Color3", PrevColor)
		end

		Ceive.AOTWireframeHandle:AddText(Origin, Text, Size)
	else
		if DROP_SHADOW then
			local DistanceToCamera = (Origin - Camera.CFrame.Position).Magnitude
			local PrevColor = Ceive.PopProperty("Color3")

			Ceive.PushProperty("Color3", Color3.new())
			local Offset = -(Vector3.xAxis + Vector3.yAxis).Unit
			Ceive.WireframeHandle:AddText(Origin + Offset * (DistanceToCamera * OFFSET_PERCENTAGE), Text, Size)
			Ceive.PushProperty("Color3", PrevColor)
		end

		Ceive.WireframeHandle:AddText(Origin, Text, Size)
	end

	-- Should text count to active rays?
	--self.Ceive.ActiveRays += 1

	self.Ceive.ScheduleCleaning()
end

function Gizmo:Create(Origin: Vector3, Text: string, Size: number?)
	local PropertyTable = {
		Origin = Origin,
		Text = Text,
		Size = Size,
		AlwaysOnTop = self.Propertys.AlwaysOnTop,
		Transparency = self.Propertys.Transparency,
		Color3 = self.Propertys.Color3,
		Enabled = true,
		Destroy = false,
	}

	self.Retain(self, PropertyTable)

	return PropertyTable
end

function Gizmo:Update(PropertyTable)
	local Ceive = self.Ceive

	Ceive.PushProperty("AlwaysOnTop", PropertyTable.AlwaysOnTop)
	Ceive.PushProperty("Transparency", PropertyTable.Transparency)
	Ceive.PushProperty("Color3", PropertyTable.Color3)

	self:Draw(PropertyTable.Origin, PropertyTable.Text, PropertyTable.Size)
end

return Gizmo
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>